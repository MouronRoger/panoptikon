[
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Ai_Documentation_Guide",
    "identifier": "AI_DOCUMENTATION_GUIDE.md",
    "text": "# AI Documentation Guide - Panoptikon\n\nThis guide provides comprehensive information about the Panoptikon documentation system, which uses Qdrant for semantic search and integrates with the MCP server.\n\n## System Overview\n\nThe Panoptikon project uses a unified Qdrant-based documentation system for all documentation storage, indexing, and retrieval.\n\n### Key Components\n\n1. **Qdrant Cloud Instance**\n   - **Collection Name**: `panoptikon` (unified for all documentation)\n   - **Vector Model**: all-MiniLM-L6-v2 (384 dimensions)\n   - **Vector Name** (for MCP): `fast-all-minilm-l6-v2`\n   - **URL**: Configured in scripts\n\n2. **Documentation Scripts**\n   - **Primary Interface**: `/scripts/documentation/ai_docs.py`\n     - Main AI-accessible interface for documentation\n     - Automatically creates markdown files and indexes them in Qdrant\n     - Provides functions for creating, updating, searching documentation\n   \n   - **Utility Scripts**: `/scripts/qdrant/`\n     - `index_docs.py` - Index documentation to Qdrant\n     - `index_docs_mcp.py` - MCP-compatible indexing with named vectors\n     - `search_docs.py` - Search indexed documentation\n     - `manage.py` - Manage Qdrant collection\n     - `test_mcp.py` - Test MCP integration\n     - `qdrant.sh` - Wrapper script for all operations\n\n3. **MCP Server Integration**\n   - Uses the `panoptikon` collection\n   - Provides semantic search capabilities\n   - Requires `document` field in payload\n   - Syncs automatically when documents are created/updated\n\n## Usage Examples\n\n```python\n# Import the documentation system\nfrom scripts.documentation.ai_docs import *\n\n# Create new documentation\ncreate_documentation(\n    category=\"components\",\n    title=\"Event Bus\",\n    content=\"# Event Bus\\n\\nThe event bus provides pub/sub communication...\",\n    tags=[\"core\", \"messaging\"],\n    status=\"completed\"\n)\n\n# Read existing documentation\ndoc = read_documentation(\"components\", \"Event Bus\")\nprint(doc['content'])\n\n# Update documentation\nupdate_documentation(\n    category=\"components\",\n    title=\"Event Bus\",\n    updates={\n        'content': \"# Event Bus\\n\\nUpdated content...\",\n        'metadata': {'status': 'updated', 'version': '2.0'}\n    }\n)\n\n# Search documentation using Qdrant semantic search\nresults = search_documentation(\"database connection pooling\")\nfor result in results:\n    print(f\"{result['title']} - {result['score']}\")\n\n# Document a component\ndocument_component(\n    \"ServiceContainer\",\n    overview=\"Dependency injection container\",\n    purpose=\"Manage service lifecycles\",\n    implementation=\"Uses singleton pattern\",\n    status=\"Completed\",\n    coverage=\"94%\"\n)\n\n# Document a phase\ndocument_phase(\n    \"Phase 4 - Database Implementation\",\n    objectives=\"Implement SQLite database layer\",\n    components=[\"Schema\", \"Connection Pool\", \"Migration System\"],\n    status=\"In Progress\",\n    progress=\"Phase 4.1 complete, 4.2 needs testing\"\n)\n\n# Record an architecture decision\nrecord_decision(\n    \"Use SQLite for Storage\",\n    status=\"Accepted\",\n    context=\"Need fast, embedded database\",\n    decision=\"Use SQLite with WAL mode\",\n    consequences=\"Single writer limitation\",\n    alternatives=[\"PostgreSQL\", \"LevelDB\"]\n)\n\n# Update progress\nupdate_phase_progress(\n    \"Phase 4\",\n    status=\"In Progress\",\n    completed=[\"Schema implementation\", \"Connection pool\"],\n    issues=[\"Missing test coverage\"],\n    next=[\"Write tests\", \"Start migration system\"]\n)\n```\n\n## Available Functions\n\nAll functions automatically sync with the Qdrant cloud instance:\n\n1. `create_documentation(category, title, content, **metadata)` - Creates and indexes new docs\n2. `read_documentation(category, title)` - Reads from local files\n3. `update_documentation(category, title, updates)` - Updates and re-indexes docs\n4. `search_documentation(query, limit=5)` - Semantic search via Qdrant\n5. `document_component(name, **details)` - Create component documentation\n6. `document_phase(name, **details)` - Create phase documentation\n7. `record_decision(title, **decision_details)` - Create ADR (Architecture Decision Record)\n8. `update_phase_progress(phase, **updates)` - Update phase progress tracking\n\n## Document Categories\n\nAll documents are organized in these directories and indexed in Qdrant:\n\n- `architecture` - System design documentation\n- `components` - Individual component docs\n- `phases` - Project phase documentation\n- `testing` - Test plans and coverage\n- `api` - API documentation\n- `guides` - How-to guides\n- `decisions` - Architecture Decision Records\n- `progress` - Progress tracking\n\n## Technical Configuration\n\n### Qdrant Integration\n- **Collection**: `panoptikon`\n- **Cloud Instance**: Configured in scripts/documentation/ai_docs.py\n- **Embedding Model**: all-MiniLM-L6-v2 (384 dimensions)\n- **Automatic Indexing**: All documentation is automatically indexed on creation/update\n- **Vector Configuration**: Named vectors for MCP compatibility\n\n### Manual Operations\n\nFor manual operations, use the scripts in `scripts/qdrant/`:\n\n```bash\n# Index all documentation (MCP-compatible by default)\n./scripts/qdrant/qdrant.sh index\n\n# Search documentation\n./scripts/qdrant/qdrant.sh search \"your query\"\n\n# Check status\n./scripts/qdrant/qdrant.sh manage info\n\n# Or use the unified CLI from project root\npython docs.py index\npython docs.py search \"query\"\npython docs.py status\n```\n\n## Important Notes\n\n1. **Single Collection**: Everything uses the `panoptikon` collection\n2. **No Local Qdrant**: Always use the cloud instance\n3. **Automatic Indexing**: The ai_docs.py system automatically indexes on create/update\n4. **MCP Compatible**: The system is fully integrated with the MCP server\n5. **Document Field**: All indexed documents include a `document` field for MCP compatibility\n\n## Migration Status\n\n- \u2705 All scripts updated to use `panoptikon` collection\n- \u2705 AI documentation interface updated\n- \u2705 Cursor rules updated\n- \u2705 Old references to `panoptikon_docs` removed\n- \u2705 Scripts consolidated in `/scripts/documentation/` and `/scripts/qdrant/`\n- \u2705 MCP integration working with proper `document` field\n\n## Directory Structure\n\n```\nscripts/\n\u251c\u2500\u2500 documentation/         # AI documentation tools\n\u2502   \u251c\u2500\u2500 ai_docs.py        # Main AI documentation interface\n\u2502   \u251c\u2500\u2500 record_transition.py\n\u2502   \u251c\u2500\u2500 migrate_kg_to_docs.py\n\u2502   \u251c\u2500\u2500 migrate_complete.py\n\u2502   \u2514\u2500\u2500 simple_migrate.py\n\u2502\n\u2514\u2500\u2500 qdrant/               # Qdrant indexing tools\n    \u251c\u2500\u2500 index_docs.py     # Standard indexing\n    \u251c\u2500\u2500 index_docs_mcp.py # MCP-compatible indexing\n    \u251c\u2500\u2500 search_docs.py    # Search interface\n    \u251c\u2500\u2500 manage.py         # Collection management\n    \u251c\u2500\u2500 test_mcp.py       # MCP testing\n    \u2514\u2500\u2500 qdrant.sh         # Wrapper script\n\ndocs.py                   # Main CLI interface (project root)\n```\n\n## Packaging for Other Projects\n\nTo use this documentation system in other projects:\n\n1. Copy the `scripts/documentation/` and `scripts/qdrant/` directories\n2. Copy `docs.py` to the project root\n3. Update the Qdrant credentials and collection name in the scripts\n4. Create the necessary documentation directories (`docs/architecture`, etc.)\n5. Run `python docs.py index` to start indexing documentation\n\nThe system is designed to be self-contained and easily portable to other repositories.\n\n## Cleanup of Old Directories\n\nAfter the migration to the unified system, these old directories can be removed:\n\n```bash\n# Remove old directories (manual action required)\nrm -rf scripts/qdrant-utils/\nrm -rf qdrant_storage/\n```",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Ai_Docs",
    "identifier": "ai_docs.md",
    "text": "## [2024-06-11 16:45] #phase4.2 #connection-pool #milestone #done #transition\n- **Phase:** 4.2 (Connection Pool Management)\n- **Subphase:** Full Transition to 4.3\n- **Summary:**\n    - Migrated all Pydantic validators to v2 (@field_validator) (#done)\n    - Implemented custom exception hierarchy: ConnectionPoolError, ConnectionAcquisitionTimeout, ConnectionHealthError (#done)\n    - Created comprehensive test suite for connection pool and pool service, including high-concurrency, stress, and SQLite contention tests (#done)\n    - Documented thread-safety guarantees, context manager usage, and SQLite single-writer limitation in all public APIs (#done)\n    - Added enhanced metrics, structured logging, and debug diagnostics to the pool (#done)\n    - Ran performance benchmarks and output results to benchmark_results.md (#done)\n    - Updated README and developer docs with new usage, metrics, and migration notes (#done)\n    - All #todo items for Phase 4.2 are now #done\n- **Tags:** #done #milestone #transition #rationale #migration\n- **Rationale:**\n    - The connection pool is now robust, well-documented, and production-ready. All critical issues and technical debt for Phase 4.2 have been addressed.\n- **Next Steps:**\n    - Begin Phase 4.3 (Migration):\n        - Prepare migration plan and scripts (#todo)\n        - Implement schema versioning and migration manager (#todo)\n        - Ensure backward compatibility and test migration process (#todo)\n    - Continue to use AI documentation system for all future phases and subphases (#milestone)\n\n## [2024-06-12 09:00] #phase4.2 #phase4.3 #transition #done #milestone #migration\n- **Phase:** 4.2 (Connection Pool Management) \u2192 4.3 (Migration)\n- **Subphase:** Phase 4.2 to 4.3 Transition\n- **Summary:**\n    - All recommendations and required actions from phase4_2_to_4_3_transition.md have been completed (#done)\n    - Validators migrated to Pydantic v2 APIs (#done)\n    - Thread-safety, context manager usage, and SQLite single-writer limitations documented (#done)\n    - Custom exception hierarchy implemented and documented (#done)\n    - Test coverage increased and performance/stress tests completed (#done)\n    - Developer and API docs updated (#done)\n    - Migration plan for Phase 4.3 prepared (#done)\n    - Backward compatibility verified (#done)\n- **Tags:** #done #milestone #transition #migration #rationale\n- **Rationale:**\n    - The codebase is now fully ready for Phase 4.3. All technical debt and documentation requirements for Phase 4.2 have been addressed as per the transition spec.\n- **Next Steps:**\n    - Start implementation of schema migration system (#todo)\n    - Develop and test migration scripts (#todo)\n    - Document migration process and update progress in documentation (#todo)\n    - Monitor for any issues during migration and address promptly (#todo)",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Readme",
    "identifier": "README.md",
    "text": "# Panoptikon Documentation Directory\n\n## Overview\n\nThis directory contains all project documentation, organized by category. Each subdirectory corresponds to a valid documentation category enforced by the documentation system.\n\n## Documentation Categories\n\n| Category      | Directory         | Description                                      |\n|--------------|-------------------|--------------------------------------------------|\n| architecture  | docs/architecture | System and software architecture docs            |\n| components    | docs/components   | Documentation for individual components/modules   |\n| phases        | docs/phases       | Project phase and subphase documentation         |\n| testing       | docs/testing      | Test plans, coverage, and testing docs           |\n| api           | docs/api          | API documentation and references                 |\n| guides        | docs/guides       | How-to guides and tutorials                      |\n| decisions     | docs/decisions    | Architecture Decision Records (ADRs)             |\n| progress      | docs/progress     | Progress tracking and milestone documentation    |\n\n## Onboarding & Usage\n\n- **All documentation must be placed in the correct subdirectory.**\n- The documentation system (see `scripts/documentation/ai_docs.py`) enforces category consistency. Only the above categories are valid.\n- When creating or updating documentation, always specify the correct category. The system will raise an error if an invalid category is used.\n- For more information on the documentation system and how to contribute, see `scripts/documentation/README.md` and `AI_DOCUMENTATION_GUIDE.md`.\n\n## Example\n\n- To add a new component doc, place it in `docs/components/`.\n- To update project phase documentation, use `docs/phases/`.\n- All ADRs (decisions) go in `docs/decisions/`.\n\n## Questions?\n\nIf you are unsure which category to use, run `list_valid_categories()` from the documentation system or consult the AI assistant.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Consolidation_Summary",
    "identifier": "CONSOLIDATION_SUMMARY.md",
    "text": "# Documentation System Consolidation Summary\n\n## Actions Taken\n\n### 1. Organized Scripts\n\nCreated a clear directory structure:\n```\nscripts/\n\u251c\u2500\u2500 documentation/           # AI and documentation management\n\u2502   \u251c\u2500\u2500 ai_docs.py          # Main AI interface (uses panoptikon collection)\n\u2502   \u251c\u2500\u2500 record_transition.py # Phase transition recording\n\u2502   \u251c\u2500\u2500 migrate_kg_to_docs.py # Knowledge graph migration\n\u2502   \u251c\u2500\u2500 migrate_complete.py  # Complete migration pipeline\n\u2502   \u2514\u2500\u2500 simple_migrate.py    # Simple markdown generation\n\u2502\n\u2514\u2500\u2500 qdrant/                 # Qdrant operations\n    \u251c\u2500\u2500 index_docs.py       # Document indexing\n    \u251c\u2500\u2500 search_docs.py      # Search interface\n    \u251c\u2500\u2500 manage.py           # Collection management\n    \u2514\u2500\u2500 test_mcp.py         # MCP testing\n\ndocs.py                     # Main CLI interface (project root)\n```\n\n### 2. Updated Scripts\n\n- Fixed collection name from `panoptikon_docs` to `panoptikon` in all scripts\n- Updated import paths to reflect new directory structure\n- Consolidated functionality into main `docs.py` CLI\n\n### 3. Simplified Access\n\n**For AI/Programmatic Use:**\n```python\nfrom scripts.documentation.ai_docs import *\n```\n\n**For Manual Operations:**\n```bash\npython docs.py index       # Index all docs\npython docs.py search \"query\"  # Search\npython docs.py status      # Check status\npython docs.py migrate     # Migrate knowledge graph\n```\n\n### 4. Removed Redundancies\n\nThese files can be safely deleted:\n- `/migrate_docs.py` (root) - replaced by `docs.py`\n- `/scripts/docs_pipeline.py` - replaced by `docs.py`\n\n### 5. Unified System\n\n- Single collection: `panoptikon`\n- Single indexing method: via `scripts/qdrant/`\n- Single AI interface: via `scripts/documentation/`\n- Single CLI: `docs.py`\n\n## Next Steps\n\n1. Delete redundant files:\n```bash\nrm migrate_docs.py\nrm scripts/docs_pipeline.py\n```\n\n2. Make the new CLI executable:\n```bash\nchmod +x docs.py\n```\n\n3. Update any existing documentation that references old paths\n\nThe system is now fully consolidated with a clear, single approach to documentation management.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Pyobjc_Typing",
    "identifier": "pyobjc_typing.md",
    "text": "# PyObjC Typing Solution for Panoptikon\n\nThis document explains the \"boundary pattern\" solution we've implemented to address the type checking issues with PyObjC in our macOS application.\n\n## The Problem\n\nPyObjC stubs are incompatible with our Python version, leaving PyObjC code without proper type checking. This prevents us from maintaining a strictly typed codebase while using PyObjC for macOS native UI components.\n\n## The Solution: Boundary Pattern\n\nWe've implemented a \"boundary pattern\" that:\n\n1. Creates a clear separation between typed Python code and untyped PyObjC code\n2. Contains `# type: ignore` comments only within the boundary classes\n3. Provides properly typed interfaces for the rest of the application\n\n## Key Components\n\n### 1. Wrapper Classes (`src/panoptikon/ui/objc_wrappers.py`)\n\nThese classes:\n- Wrap PyObjC interfaces with proper Python type annotations\n- Isolate all `# type: ignore` comments\n- Provide a clean, typed API for the rest of the application\n\nExample for NSSearchField:\n\n```python\nclass SearchFieldWrapper:\n    \"\"\"Typed wrapper for NSSearchField.\"\"\"\n\n    def __init__(self, frame: Optional[Rect] = None) -> None:\n        \"\"\"Initialize with an optional frame rectangle.\"\"\"\n        if frame is not None:\n            self._search_field = AppKit.NSSearchField.alloc().initWithFrame_(\n                Foundation.NSMakeRect(*frame)\n            )\n        else:\n            self._search_field = AppKit.NSSearchField.alloc().init()\n\n    def set_placeholder(self, text: str) -> None:\n        \"\"\"Set the placeholder text.\"\"\"\n        cell = self._search_field.cell()\n        cell.setPlaceholderString_(text)\n\n    @property\n    def ns_object(self) -> Any:\n        \"\"\"Get the underlying NSSearchField object.\"\"\"\n        return self._search_field\n```\n\n### 2. Custom Type Stubs (`src/panoptikon/typings/`)\n\nWe've created minimal type stubs (.pyi files) for critical PyObjC components:\n- AppKit (NSSearchField, NSTableView, NSSegmentedControl)\n- Foundation\n- objc\n\nThese stubs define just enough types to support our application without requiring full PyObjC typing support.\n\n### 3. MyPy Configuration\n\nThe `pyproject.toml` has been updated with:\n\n```toml\n[tool.mypy]\n# Existing config...\nmypy_path = [\"src/panoptikon/typings\"]\nwarn_unused_ignores = false  # Changed because we need to use # type: ignore for PyObjC\n\n# Ignore PyObjC related imports in type checking\n[[tool.mypy.overrides]]\nmodule = \"objc\"\nignore_missing_imports = true\n\n[[tool.mypy.overrides]]\nmodule = \"Foundation\"\nignore_missing_imports = true\n\n[[tool.mypy.overrides]]\nmodule = \"AppKit\"\nignore_missing_imports = true\n\n[[tool.mypy.overrides]]\nmodule = \"Cocoa\"\nignore_missing_imports = true\n```\n\n### 4. Runtime Validation (`src/panoptikon/ui/validators.py`)\n\nWe've created runtime validators that:\n- Verify PyObjC method existence\n- Validate protocol implementation\n- Provide decorator for validating PyObjC calls at runtime\n\nExample:\n\n```python\ndef validate_table_data_source(obj: Any) -> bool:\n    \"\"\"Validate that an object can serve as an NSTableViewDataSource.\"\"\"\n    required_methods = [\n        \"numberOfRowsInTableView_\",\n        \"tableView_objectValueForTableColumn_row_\",\n    ]\n    return validate_objc_protocol_conformance(obj, required_methods)\n```\n\n### 5. Integration Tests (`tests/ui/test_objc_integration.py`)\n\nTests that verify:\n- Wrappers correctly interact with PyObjC\n- Runtime validations catch interface errors early\n- PyObjC functionality works as expected\n\nThe tests are skipped if PyObjC is not available, allowing testing on systems without PyObjC.\n\n## Usage Example (`src/panoptikon/ui/macos_app.py`)\n\nThe `FileSearchApp` class demonstrates:\n- Using the wrapper classes for PyObjC components\n- Runtime validation of delegate implementations\n- Proper typing for the application logic\n- Isolating PyObjC imports within limited scope\n\n## Benefits\n\n1. **Type Safety**: The codebase maintains strict typing for all Python code\n2. **Isolation**: PyObjC code is clearly separated and contained\n3. **Early Error Detection**: Runtime validation catches interface errors early\n4. **Maintainability**: Clear boundaries make the code easier to understand and maintain\n5. **Testability**: The solution allows for testing PyObjC code in controlled environments\n\n## Conclusion\n\nThis solution provides a robust approach to using PyObjC in a strictly typed Python application. By creating a clear boundary between typed Python code and untyped PyObjC code, we can maintain type safety throughout the codebase while still leveraging the power of PyObjC for macOS native UI components.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "# Panoptikon Code Error Priority List",
    "identifier": "spec/# Panoptikon Code Error Priority List.md",
    "text": "# # Panoptikon Code Error Priority List\n# Critical (Fix Immediately)\n* \u26a0\ufe0f Dataclass ordering: Non-default attributes after default ones\n* \u26a0\ufe0f MRO issues in class inheritance\n* \u26a0\ufe0f Null safety: Calling methods on potential None values\n* \u26a0\ufe0f Circular dependencies\n\n\u2800High (Fix Before Merge)\n* Type annotation correctness and null safety\n* Function complexity > 10\n* Missing type annotations\n* Unhandled exceptions\n* Proper thread safety\n* Memory leaks in PyObjC code\n\n\u2800Medium (Fix During Code Review)\n* Modern syntax: Use list not List, X | Y not Union[X, Y]\n* Nested if statements and control flow\n* File length > 500 lines\n* Function length > 50 lines\n* Unused imports and code\n\n\u2800Low (Fix When Convenient)\n* Line length consistency\n* Docstring coverage\n* Using optimized patterns (contextlib.suppress)\n* Import order\n* String format consistency\n\n\u2800Include this with prompts to remind of error priorities during development.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Knowledge Graph Prompt",
    "identifier": "spec/knowledge-graph-prompt.md",
    "text": "# **. Entity Extraction**\n* Detect and extract **new entities** (\ud83d\udce6 components, \ud83e\uddf1 modules, \ud83d\udd27 services, \ud83e\uddea test types, \u2699\ufe0f configurations).\n* Classify them under existing architecture domains:\n  * Core Infrastructure, File System Layer, Data Layer, Search Engine, Indexing System, UI, System Integration.\n\n\u2800**\ud83d\udd17 2. Relationship Mapping**\n* Identify and log **functional dependencies** between components (e.g., Search Engine depends on Query Parser \u2192 Query Parser uses Configuration System).\n* Represent **bidirectional links** between subsystems using structured triples (e.g., Search Engine \u2194 UI Framework via \"Result Presentation\").\n\n\u2800**\ud83c\udff7\ufe0f 3. Tagging & Contextual Labelling**\n* Auto-apply tags based on context:\n  * #critical_path, #performance_risk, #macOS_api, #permissions, #cloud_sync, #UI_threading, etc.\n* Use phase and milestone references (Phase_2_Core, Milestone_FoundationReady) for time-specific tags.\n\n\u2800**\u267b\ufe0f 4. Dynamic Graph Update**\n* Insert or update nodes and edges in the knowledge graph:\n  * Ensure **no orphan nodes** (all new entities must connect to at least one functional parent or dependency).\n  * Prune **redundant or outdated nodes** (e.g., deprecated abstractions or superseded modules).\n\n\u2800**\ud83e\uddea 5. Verification & Consistency Checks**\n* Confirm:\n  * All #dependencies are valid and resolvable across phases.\n  * Tags reflect current **risk status**, **ownership**, and **implementation state**.\n  * Phase dependencies remain **acyclic** and **chronologically coherent**.\n\n\u2800**\ud83d\udce4 6. Snapshot and Log**\n* Save the updated graph state as a timestamped JSON-LD or RDF snapshot.\n* Log:\n  * Changeset summary: +3 nodes, +4 edges, -1 deprecated\n  * Top-level diffs by subsystem\n  * Any unresolved tagging or dependency issues\n\n\u2800\n\ud83d\udcce **Use Context:**Panoptikon follows a modular, phase-based architecture with resilient OS abstractions, a search/index core, and layered UI/system integration. The knowledge graph is critical for keeping this complex architecture traceable, auditable, and auto-refactorable.\n\ud83d\udee0\ufe0f **Tech Context:** Python 3.11+, PyObjC, SQLite (WAL mode), Event-driven architecture, strict lint/test gates.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Client Panoptikon Spec",
    "identifier": "spec/Client-panoptikon-spec.md",
    "text": "# \ud83d\udcd1 **Panoptikon Client Specification**\n\n## \ud83d\udccb **Release Strategy and Core Philosophy**\n\n**Phase 1 Focus - Minimal \"Everything\" Clone**: The initial release of Panoptikon will deliver a focused, high-performance file search application that indexes and searches by filename only, similar to the popular Windows utility \"Everything\". This approach prioritizes speed, reliability, and immediate utility while establishing the architectural foundation for future enhancements.\n\n**Core Design Philosophy**: \"The idea of the Panoptikon is that it knows where everything is. It has no blindspots.\" The application must provide comprehensive visibility across all file storage locations with zero configuration, delivering instant results regardless of where files are stored.\n\n**Deferred Capabilities**: Content indexing, OCR, full-text search, advanced boolean operators, intelligent ranking, CLI integration, watch queries, and metadata filtering are explicitly deferred to future releases. The architecture will be designed with extension points to ensure these capabilities can be added later without significant refactoring.\n\n**Essential Core Features**: The initial release will focus exclusively on ultra-fast filename search, customizable tabs, basic filtering options, seamless cloud integration, flexible column customization, and native macOS integration with Finder.\n\n## \ud83d\ude80 **Purpose and Scope**\n\nPanoptikon is a fast, lightweight file-search application for macOS, designed to help individual users reclaim control over scattered data. By day one, it must deliver an intuitive, high-performance search experience that locates files by name across local disks, network shares, and popular cloud services. This document captures, in concrete terms, every requirement Panoptikon must deliver before any technical architecture work begins. Its language is precise and measurable, ensuring no requirement remains open to interpretation.\n\n## \ud83c\udfaf **Target Audience**\n\nPanoptikon serves three primary user groups: students managing research papers and lecture notes; home users organizing personal documents and media; and home-office workers handling reports, spreadsheets, and contracts. It explicitly excludes specialized workflows such as film editing, music production, or real-time collaboration.\n\n## \ud83d\udda5\ufe0f **Context of Use**\n\nA user invokes Panoptikon via a global hotkey, the menu-bar icon, or the Dock. Within a fraction of a second, a minimalist window appears with the search field focused. As the user types a filename fragment, matching entries populate instantly in a familiar list view. Users accustomed to macOS drag-and-drop and Finder context menus feel at home immediately; those switching from Windows recognize the responsiveness reminiscent of \"Everything.\"\n\n## \ud83c\udfa8 **User Interface and Design**\n\n**Tabbed Layout**: Search results display within a tabbed interface at the top of the window. Tabs default to categories (All Files, Documents, Spreadsheets, PDFs, Folders, Images, Audio, Video, Archive, Apps, Custom) and can be user-defined. Switching tabs filters results by predefined or custom criteria without losing the search query.\n\n**Customizable Tabs (Preset, Not Hardcoded)**: The default tab set (All Files, Documents, PDFs, etc.) is provided as a starting point but is not fixed. Users can rename, delete, reorder, or add tabs via contextual interaction. Each tab maps to a saved filter configuration\u2014by file type, extension, or path rules\u2014which the user can modify directly. Tab definitions persist across sessions and reflect user preferences without requiring reconfiguration.\n\n**Columns and Context Menus**: The default columns\u2014Name, Type, Extension, Size, Date Created, Date Modified, Path, and Cloud Status\u2014appear in a sortable list. Users may reveal, hide, and reorder columns through direct manipulation of the header. Right-clicking or two-finger tapping any row exposes Finder-consistent commands: Open, Open With\u2026, Reveal in Finder, Quick Look, Copy Path, and Move to Trash. All commands apply seamlessly to multiple selected rows.\n\n***Dual Input Method Support***: The interface provides ***equal emphasis on keyboard shortcuts for Mac power users alongside comprehensive right-click context menus for Windows migrants***. ***Mouse hover tooltips assist Windows users unfamiliar with Mac conventions***, while ***visual indicators clearly show all available actions accessible via both mouse and keyboard methods***. This dual-input design ensures both user groups can operate efficiently according to their established habits.\n\n***Interaction Consistency***: The application ***maintains Mac interface conventions while simultaneously providing familiar Windows equivalents***. Drag-and-drop operations ***behave exactly as expected in Finder while offering familiar feedback for Windows users***. The interface includes a ***status bar with information presentation familiar to Windows users without compromising Mac aesthetics***. The application ***supports both Mac trackpad gestures and Windows-style mouse wheel behaviors*** for navigation and interaction.\n\n## \u2699\ufe0f **Functional Requirements**\n\n**Search Filtering by Filename**: The search field filters by filename alone, updating results with no perceptible lag and smooth, flicker-free rendering. As the core functionality of Phase 1, this capability must be optimized for maximum performance and reliability.\n\n**Basic Search Capabilities**: Panoptikon supports simple, intuitive search patterns that focus on filename matching. Core search functionality includes:\n\n* Wildcard patterns (\\*, ?) for flexible filename matching\n* Case-sensitive or case-insensitive matching via a simple toggle\n* Whole word matching via a simple toggle\n* Extension filtering via a dedicated adjacent field for quick `*.extension` searches\n\nComplex boolean operators and special syntax are intentionally omitted to maintain simplicity and performance.\n\n**Bookmarks and Favorites**: Users can bookmark frequently accessed files, folders, or searches for rapid access. Bookmarks persist across sessions and can be organized within the interface. This feature provides quick access to important items without requiring complex search history management.\n\n**Path Inclusion/Exclusion Logic**: Users can define include and exclude rules for file paths. Include rules accept specific folders or volumes; exclude rules omit specified directories, subtrees, or mount points. The UI exposes a preferences panel where users add, edit, and reorder path rules. Exclude rules take precedence over include rules.\n\n**File Type Inclusion/Exclusion Filters**: Beyond tabs, users can create custom file-type filters by specifying extensions or MIME types. These filters integrate with tabs and can be toggled in the preferences panel, enabling or disabling types globally or per tab.\n\n**Granular Inclusion/Exclusion Control**: The system allows for fine-grained control where users can exclude specific paths, files, and filetypes while including others. ***Importantly, the system supports hierarchical overrides where a child directory can be explicitly included even when its parent directory is excluded***. This capability is especially relevant for cloud storage files typically stored in system locations like the .library folder, allowing users to include cloud documents without indexing the entire system directory structure.\n\n**Indexing Progress Indicator**: During initial indexing or manual updates, a non-intrusive progress indicator displays percent-complete and estimated time remaining. Users may pause or throttle indexing threads via preferences to control resource usage.\n\n***Visual Disambiguation***: The interface provides ***clear visual distinction for files with identical names in different locations***, ensuring users can immediately identify the specific file they need. ***Path information is immediately visible without requiring additional clicks or hover actions***. The system provides ***instant visual feedback when typing matches zero files***, and includes ***progressive loading indicators for very large result sets*** to maintain responsive feel.\n\n## \u2601\ufe0f **Cloud and Network Integration**\n\nPanoptikon's index includes files on internal drives, connected external volumes, network shares, and supported cloud providers\u2014iCloud, Dropbox, Google Drive, OneDrive, and Box. Files downloaded to disk display on a neutral background; placeholders for cloud-only items appear tinted, with a tooltip explaining that the file must be hydrated before opening. Rows for unavailable network volumes appear dimmed and revive instantly once the volume reconnects.\n\n**Seamless Cloud Delegation**: Panoptikon does not directly integrate each cloud provider's API. Instead, it delegates file hydration and opening to the system's native integration or provider-specific helper, invoking a single standard call to reveal or open a file path. This approach ensures a transparent, consistent user experience where cloud document downloads and opening are deferred seamlessly and invisibly to Finder. The user should never need to consider whether a file is cloud-based or local\u2014Panoptikon knows where everything is with no blindspots, and handles the details transparently.\n\n## \ud83d\uddc4\ufe0f **Database and Caching**\n\nPanoptikon maintains a local, lightweight database to store file index metadata. This database persists between launches, supports incremental updates driven by filesystem events, and caches information about offline or cloud-only files to avoid costly full re-indexing. When a network or cloud file is unavailable, its metadata remains accessible in the database so that the app can display placeholder entries instantly and hydrate files on demand without delaying search results.\n\n**Future-Proof Database Design**: While the initial release focuses on filename indexing only, the database schema will be designed with extensibility in mind, including provisions for future content-based search capabilities. This forward-looking approach ensures that future enhancements can be added without requiring database migration or redesign.\n\n## \u26a1 **Performance and Resource Constraints**\n\nInitial indexing of up to 250,000 files shall complete in under one minute on an Apple Silicon MacBook Air, consuming no more than twenty percent of a single CPU core and 500 MB of RAM. Incremental updates driven by filesystem events must never block the UI and must process batches in under fifty milliseconds. From final keystroke to fully rendered results, search latency must remain below fifty milliseconds for indexes up to 250,000 entries. Launch time from invoking the hotkey to a focused search field must stay under one hundred milliseconds under normal system load. When idle, Panoptikon's resident memory footprint must remain below fifty megabytes and CPU usage must be negligible.\n\n***Speed Benchmarks From User Perspective***: To ensure the application feels instantaneous to users, the following metrics must be met: ***\"no perceptible lag\" is defined as under 16ms (one frame) response time between user action and visible feedback***; ***\"instant appearance\" requires first results to be visible within 50ms of keystroke***; ***complete result set updates must occur within 100ms maximum***; and ***UI rendering must maintain minimum 60fps during typing and scrolling operations***. These benchmarks ensure the application feels native and responsive to both Mac and Windows users accustomed to high-performance search.\n\n## \ud83c\udf10 **Accessibility, Internationalization, and Localization**\n\nEvery control carries an accessibility label and is fully operable via VoiceOver and keyboard alone, enabling users to perform searches, apply filters, execute context commands, switch tabs, and quit the app without a pointing device. All user-visible text loads from localization files; the initial languages supported are English, French, and German. The interface respects system settings for Dark Mode, increased contrast, and dynamic type sizes.\n\n## \ud83d\udd12 **Privacy, Permissions, and Security**\n\nPanoptikon's entire index resides locally within the user's Library container and, if FileVault is enabled, benefits from disk encryption. Under no circumstances does the app transmit filenames, paths, or usage metrics off-device. On first launch, Panoptikon requests Full Disk Access through standard macOS entitlements. If the user declines, the app continues to index accessible locations and displays a non-intrusive banner explaining reduced visibility, with a link to help documentation. The application bundle is notarized, sandboxed, and signed with a Developer ID certificate. Updates are delivered securely via Sparkle with ed25519 verification.\n\n## \ud83e\udde9 **Platform Support and Non-Functional Constraints**\n\nPanoptikon supports macOS 13 (Ventura) and later, on both Apple Silicon and Intel architectures. Continuous integration tests enforce all performance metrics and fail the build on regression. User data structures are resilient to sudden power loss; index rebuilds occur only on first launch or after a verified corruption event. The codebase adheres to native Apple Human Interface Guidelines, ensuring a polished, familiar experience.\n\n## \ud83c\udfd7\ufe0f **Architectural Decisions**\n\n**Phase 1 Focus**: Phase 1 will implement fast, filename-only search with all advanced search filters\u2014boolean logic, date range, and size range. The architecture will establish clear boundaries between index management, search operations, and UI components, with well-defined interfaces to support future capabilities.\n\n**Deferred Features**: Content indexing, OCR, and full-text search capabilities are deliberately deferred to future phases. However, the architecture will be designed with these capabilities in mind, with clear extension points identified during the design phase.\n\n**Technical Foundations**: Offline network volumes and cloud\u2011only files leverage the lightweight database cache to guarantee sub\u2011100 ms response times. Duplicate filenames remain separate entries; grouping modes and further UI refinements will be revisited in post\u20111.0 updates.\n\n## \u2b50 **Additional User-Centric Features**\n\n**Inline Preview Pane**: A resizable side panel displays Quick Look previews (text, PDF, image, audio waveforms, video thumbnails) for the selected file without opening a separate window.\n\n**Content Search Option (Future Phase)**: In future releases, Panoptikon will expand beyond filename search to include content indexing capabilities. This will enable users to search within file contents (text, PDF, Office docs) with appropriate resource management controls. Similarly, OCR-powered text extraction for images and scanned PDFs will be implemented in a future phase. The Phase 1 architecture will be designed with these capabilities in mind to ensure smooth integration when implemented.\n\n**Drag and Drop Support**: Comprehensive drag and drop functionality is supported throughout the application:\n* Drag files from results to Finder or other applications\n* Drag files between multiple Panoptikon windows\n* Drag files to the Dock, Desktop, or folders\nThis integration with macOS's native drag and drop capabilities ensures seamless workflow integration.\n\n**File Information Display**: Basic file metadata (size, dates, extension, type) is displayed in the results list through customizable columns. Advanced metadata filtering and tag-based searches are deferred to future releases to maintain focus on core filename search functionality.\n\n**Favorites and Pinned Searches**: Users can mark folders or files as favorites for rapid access and pin saved searches to the UI toolbar. Keyboard shortcuts allow quick jumping to favorites or pinned queries.\n\n**Keyboard-Driven Workflow**: Complete operation via keyboard: global hotkey to invoke search, arrow keys to navigate results, Return to open, spacebar to Quick Look, and customizable shortcuts for context commands.\n\n**Rich Context Menu Options**: Right-click context menus provide essential file operations including:\n* Open\n* Open with...\n* Reveal in Finder\n* Copy path (full path to clipboard)\n* Copy filename (just the filename to clipboard)\n* Move to Trash\nThese operations apply seamlessly to multiple selected files.\n\n**Multi-Window Support**: Users can open multiple Panoptikon windows simultaneously, each with independent search queries and result views. Drag and drop operations are supported both within and between windows, enabling efficient file management workflows.\n\n**Flexible Column Customization**: The results view offers comprehensive column customization:\n* Users can show/hide individual columns\n* Available columns include: Name, Path, Size, Extension, Type, Date Modified, Date Created, Date Accessed, and Run Count\n* Folder size calculation is supported where possible\n* Columns are sortable by clicking headers\n* Column positions can be changed via drag and drop\n* Column preferences persist across sessions\n\n**Import/Export Settings**: Preferences, bookmarks, inclusion/exclusion rules, and column configurations are exportable to a JSON settings file for backup or sharing.\n\n## \ud83d\udcca **Default Sorting and User Control**\n\n**Simple, Predictable Sorting**: By default, search results are sorted by most recently modified files at the top, followed by alphabetical ordering. This approach ensures the most relevant files typically appear first without complex ranking algorithms.\n\n**User-Controlled Sorting**: Users can manually sort the results by clicking any column header (Name, Date Modified, Size, etc.) to change the sort order. This gives direct control over result organization without automatic or \"intelligent\" intervention.\n\n**Basic Run Count Tracking**: The system maintains a simple count of file opens to support the \"Run Count\" column, but does not implement complex usage analytics or predictive sorting.\n\n## \u2705 **Success Criteria**\n\n**Phase 1 Success Criteria**: Panoptikon is production-ready when an unbiased tester with 250,000 files can:\n1. Launch the search window\n2. Find a specified file by filename\n3. Open it in under one second end-to-end\n4. Successfully work with local, network, and cloud files without configuration\n5. Perform the above while macOS's Activity Monitor never flags Panoptikon as a top resource consumer\n\nThis criterion focuses exclusively on filename-based search performance and comprehensive file system visibility, aligning with the \"no blindspots\" philosophy and Phase 1 scope.\n\n**Future Phase Success Criteria**: Success criteria for content indexing and OCR capabilities will be defined in future specification updates. The architecture must be designed to accommodate these capabilities without compromising the core performance metrics established for Phase 1.\n\n**Additional Scalability Goal (Optional)**: The system should handle larger indexes gracefully for power users, scaling up to 1,000,000 files with proportional performance, documented as aspirational targets.\n\n## \ud83d\udee0\ufe0f **System\u2011Designer Instructions (KISS & Land Rover Philosophy)**\n\n### \ud83c\udf10 **Target users**\n\nConsumers; students; home and small\u2011office workers; busy secretaries and administrators; small\u2011business managers.\n\n### \ud83d\udeab **Non\u2011targets**\n\nLarge enterprises; media producers; software developers.\n\n### \ud83d\udea6 **Guiding principles**\n\nSimplicity; robustness; zero surprises; no bloat; essentials only; every line must be justified by daily utility.\n\n### \ud83d\udd29 **Coding standards**\n\nPython 3.11 + PyObjC; single\u2011purpose modules; hard limit 500 lines per file; PEP 8 plus strict linting; cyclomatic complexity < 10 per function; no dead code tolerated; commits rejected if mypy or flake8 emit warnings.\n\n### \ud83e\uddea **Testing & build pipeline**\n\nTests accompany every module; unit coverage \u2265 95 % with pytest; integration smoke test after each merge; CI stops on first error; artefacts versioned and checksummed; refactors forbidden during stabilisation; critical\u2011path tasks mapped and gated.\n\n### \ud83d\udce6 **Packaging workflow**\n\nPrototype with editable PyObjC sources; strip to essentials; avoid external pip packages unless unavoidable (each usage must be justified and reviewed). Bundle with py2app; exclude unused stdlib modules; set `argv_emulation=False` and `LSUIElement=True` for background mode.\n\nAfter stabilisation, compile with Nuitka to a self\u2011contained binary; wrap in Platypus or hand\u2011craft the .app bundle; remove unreferenced locales, docs, and resources; optionally UPX\u2011compress .so/.dylib files if size reduction > 10 % and no measurable performance loss.\n\n### \ud83d\udccf **Size & performance budgets**\n\nInstalled .app \u2264 30 MB; cold launch \u2264 300 ms on a 2015 MacBook Air; peak RAM < 150 MB; full\u2011index search across 100 k files in < 0.5 s.\n\n### \ud83d\udeab **Forbidden practices**\n\nNo hidden network calls; no telemetry; no reflection magic; no runtime code generation; no monkey\u2011patching; never break stable APIs once released.\n\n### \u2705 **Definition of Done**\n\nBinary reproduces from clean checkout with a single `make` command; all tests green; notarisation and codesigning passed; user installs by drag\u2011and\u2011drop and runs without prompts; macOS Gatekeeper accepts; zero console warnings on launch.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Project_Summary",
    "identifier": "spec/phases/project_summary.md",
    "text": "# \ud83d\udea7 PANOPTIKON PROJECT - IMPLEMENTATION PLAN\n\n## \ud83d\udccb Project Overview\n\nPanoptikon is a high-performance macOS filename search utility designed to provide instant search across all storage locations with zero configuration. The application focuses on delivering sub-50ms search response times, complete visibility across local, network, and cloud storage, and a dual-paradigm interface supporting both keyboard and mouse workflows.\n\n## \ud83d\udd04 Implementation Approach\n\nThe project will be implemented in 11 distinct phases, each with clear objectives, tasks, testing requirements, and deliverables. Each phase builds upon the previous ones, gradually constructing the complete system while maintaining testability, quality, and focused OS resilience.\n\n## \ud83d\udcd1 Phase Structure\n\nEach phase follows a consistent structure:\n\n1. **Load Module Spec**: Review relevant specifications from project documentation\n2. **Analyze Context**: Identify objectives, interfaces, constraints, and dependencies\n3. **Construct Prompt**: Define specific implementation tasks and requirements\n4. **Implement**: Execute the defined tasks following strict coding standards\n5. **Test and Format**: Verify implementation meets requirements and follows standards\n6. **Propagate State**: Document completion with report, prompt archive, and knowledge graph update\n\n## \ud83d\udcca Quality Control\n\nThroughout all phases, the following quality standards will be maintained:\n\n- **Zero lint errors**: All code must pass flake8 with plugins\n- **Type safety**: All code must pass mypy in strict mode\n- **Test coverage**: Minimum 95% code coverage required\n- **Performance**: Regular benchmarking against target metrics\n- **Architecture**: Strict adherence to defined patterns and interfaces\n- **Documentation**: Complete documentation for all public interfaces\n\n## \ud83d\udcc5 Implementation Timeline\n\nThe 11 phases are designed to be implemented sequentially:\n\n1. **Project Setup** (Foundation) - Week 1-2\n2. **Core Infrastructure** (Framework) - Week 3\n3. **Filesystem Abstraction** (Critical OS Layer) - Week 3-4\n4. **Database Foundation** (Data Layer) - Week 4-5\n5. **Search Engine** (Core Functionality) - Week 5-6\n6. **Indexing System** (Core Functionality) - Week 6-7\n7. **UI Framework** (User Experience) - Week 7-8\n8. **Cloud Integration** (Extended Functionality) - Week 9\n9. **System Integration** (Extended Functionality) - Week 9-10\n10. **Optimization** (Performance) - Week 10-12\n11. **Packaging** (Release) - Week 13\n\n## \ud83c\udfc6 Success Criteria\n\nThe project will be considered successful when:\n\n1. **Performance targets** are consistently met:\n   - Search latency <50ms\n   - Launch time <100ms\n   - UI rendering at 60fps\n   - Indexing 250k files in <60s\n\n2. **Quality targets** are achieved:\n   - Zero known critical bugs\n   - Test coverage \u226595%\n   - All accessibility requirements met\n   - Bundle size <30MB\n\n3. **User experience** goals are realized:\n   - Complete first-run experience\n   - Dual-paradigm support verified\n   - Cloud integration working seamlessly\n   - All core workflows tested and functional\n\n## \ud83d\ude80 Next Steps\n\nDevelopment will begin with Phase 1: Project Setup, establishing the foundation for all subsequent phases. Each phase will include comprehensive documentation and testing to ensure consistent progress and maintainable code.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_4_Optimization",
    "identifier": "spec/phases/phase4_4_optimization.md",
    "text": "# \u26a1 PHASE 4.4: QUERY OPTIMIZATION SYSTEM\n\n## \ud83d\udcdd OBJECTIVES\n- Implement prepared statement management\n- Create query parameterization helpers\n- Build query performance monitoring\n- Establish statement caching system\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n### 1. Prepared Statement Framework \ud83d\udccb\n- **Statement Registry**: Centralized prepared statements\n- **Parameter Binding**: Safe value substitution\n- **Statement Caching**: Reuse compiled queries\n- **Lifecycle Management**: Statement cleanup\n\n### 2. Query Builder Utilities \ud83d\udee0\ufe0f\n```python\n# Safe query construction:\n# - Parameter placeholders (?)\n# - Type-safe bindings\n# - SQL injection prevention\n# - Dynamic query composition\n```\n\n### 3. Performance Monitoring \ud83d\udcca\n1. Query execution timing\n2. EXPLAIN QUERY PLAN analysis\n3. Index usage tracking\n4. Slow query identification\n5. Query frequency analysis\n\n### 4. Optimization Strategies \ud83c\udfaf\n- **Index Hints**: Guide SQLite query planner\n- **Query Rewriting**: Optimize common patterns\n- **Batch Operations**: Reduce round trips\n- **Cache Strategy**: Frequently used results\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Test parameterized query safety\n- Verify statement caching effectiveness\n- Measure query performance improvements\n- Test with various data volumes\n- Validate EXPLAIN plan analysis\n- Test batch operation performance\n- Ensure SQL injection prevention\n- Maintain 95% code coverage\n\n## \ud83c\udfaf SUCCESS CRITERIA\n- Parameterized queries prevent SQL injection\n- Statement caching reduces parse time 50%+\n- Query monitoring identifies slow queries\n- Batch operations 10x faster than individual\n- EXPLAIN analysis provides insights\n\n## \ud83d\udeab CONSTRAINTS\n- Use only SQLite built-in features\n- No query plan hints (SQLite limitation)\n- Parameter count limit (999 in SQLite)\n- Must work with all transaction types\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 4.2: Connection pool (execution context)\n- Phase 4.1: Schema (query targets)\n- Phase 2: Logging system (performance logs)\n- Phase 2: Metrics collection (timing data)\n\n## \ud83c\udfd7\ufe0f CODE STANDARDS\n- **Query Format**: Consistent SQL style guide\n- **Parameter Names**: Descriptive binding names\n- **Performance Targets**: Document expected times\n- **Security**: All user input parameterized\n- **Monitoring**: Structured performance logs\n- **Caching**: Clear cache invalidation rules",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase10_Prompt",
    "identifier": "spec/phases/phase10_prompt.md",
    "text": "# \ud83d\udea7 PHASE 10: OPTIMIZATION\n\n## \ud83d\udcdd OBJECTIVES\n- Fine-tune performance to meet all target metrics\n- Optimize memory usage and management\n- Verify resilience mechanisms work reliably\n- Refine user experience details\n- Implement comprehensive monitoring\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Performance Optimization**:\n   - Fine-tune application startup to <100ms\n   - Optimize search latency to consistently <50ms\n   - Ensure UI renders at 60fps at all times\n   - Improve indexing speed to handle 250k files in <60s\n   - Minimize memory and CPU footprint\n\n2. **Memory Management**:\n   - Profile and fix memory leaks\n   - Optimize caching strategies\n   - Improve PyObjC boundary crossing patterns\n   - Ensure proper object ownership and thread confinement\n   - Implement dynamic resource adjustment\n\n3. **Resilience Verification**:\n   - Test file monitoring across various scenarios\n   - Validate behavior with different permission levels\n   - Verify cloud integration across providers\n   - Test component abstraction effectiveness\n   - Enhance recovery mechanisms\n\n4. **User Experience Refinement**:\n   - Create welcoming first-run experience\n   - Implement contextual help system\n   - Finalize keyboard shortcuts\n   - Polish UI details and animations\n   - Add subtle user guidance\n\n5. **Monitoring and Diagnostics**:\n   - Implement performance tracking\n   - Create diagnostic logging\n   - Build crash reporting mechanism\n   - Design usage analytics (opt-in)\n   - Develop troubleshooting tools\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify all performance targets consistently met:\n  - Launch time <100ms\n  - Search latency <50ms\n  - UI rendering at 60fps\n  - Indexing 250k files in <60s\n  - Idle memory usage <50MB\n  - Bundle size <30MB\n- Test resilience under various conditions\n- Validate user experience with focus groups\n- Verify all features work on target OS versions\n\n## \ud83d\udeab CONSTRAINTS\n- Maintain performance focus\n- Ensure accessibility compliance\n- Keep resource usage minimal\n- Preserve battery efficiency\n\n## \ud83d\udccb DEPENDENCIES\n- All previous phases",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase7_Prompt",
    "identifier": "spec/phases/phase7_prompt.md",
    "text": "# \ud83d\udea7 PHASE 7: UI FRAMEWORK\n\n## \ud83d\udcdd OBJECTIVES\n- Implement native macOS UI with AppKit via PyObjC\n- Create dual-paradigm interface (keyboard and mouse)\n- Build search field, tab bar, and results table\n- Implement context menus and file operations\n- Develop progress visualization and status displays\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Window and Controls**:\n   - Implement main application window\n   - Create search input with real-time filtering\n   - Build tab bar for category filtering\n   - Implement virtual table view for results\n   - Create column management system\n\n2. **Interaction Model**:\n   - Implement comprehensive keyboard navigation\n   - Create context menus for operations\n   - Build drag and drop support\n   - Implement selection management\n   - Design default file actions\n\n3. **UI Component Abstraction**:\n   - Implement composition pattern for UI\n   - Create separation between UI and business logic\n   - Build accessibility support for VoiceOver\n   - Design layout adaptation for screen densities\n\n4. **Progress and Feedback**:\n   - Create non-intrusive progress visualization\n   - Implement status bar for information\n   - Add contextual tooltips\n   - Build user-friendly error notifications\n   - Create smooth animations and transitions\n\n5. **UI-Core Integration**:\n   - Implement search integration\n   - Create result display binding\n   - Build operation delegation\n   - Design state synchronization\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify UI renders at 60fps during operations\n- Test keyboard navigation covers all functions\n- Validate context menus work correctly\n- Measure UI responsiveness during indexing\n- Verify VoiceOver accessibility\n- Test UI with large result sets\n- Maintain interface compliance with HIG\n- Test UI component isolation\n\n## \ud83d\udeab CONSTRAINTS\n- Use composition over inheritance for UI\n- Maintain clear separation of concerns\n- Design for resilience against UI framework changes\n- Support both keyboard and mouse workflows equally\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 5 search engine\n- Phase 6 indexing system",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase3 Partial_Completion",
    "identifier": "spec/phases/phase3-partial_completion.md",
    "text": "# # \ud83d\udea7 Panoptikon\u00a0Phase\u00a03: Filesystem Abstraction\n## Partial Completion\u00a0Report\n### \ud83d\udccb Overview\nPhase\u00a03 of\u00a0Panoptikon\u00a0focuses\u00a0on building\u00a0a\u00a0resilient, permission-aware, and\u00a0testable\u00a0filesystem abstraction. The goal\u00a0is\u00a0to\u00a0support robust\u00a0file\u00a0monitoring, cloud storage\u00a0detection, security-scoped\u00a0bookmarks, and\u00a0advanced\u00a0path\u00a0management, all\u00a0with\u00a0clear\u00a0boundaries\u00a0and\u00a0dependency injection. This\u00a0phase\u00a0builds\u00a0on the\u00a0service\u00a0container, event\u00a0bus, and\u00a0configuration\u00a0systems\u00a0from\u00a0Phase\u00a02.\nAs\u00a0of\u00a0this report, the\u00a0majority\u00a0of\u00a0core infrastructure\u00a0for\u00a0filesystem monitoring, path\u00a0management, and security\u00a0bookmarks\u00a0is implemented. Some\u00a0features\u2014such\u00a0as\u00a0full cloud\u00a0provider\u00a0detection, advanced permission handling, and\u00a0comprehensive\u00a0automated\u00a0testing\u2014remain\u00a0in\u00a0progress.\n\n## \u2705 Completed\u00a0Components\n### 1.\u00a0FSEvents Wrapper\n* **FSWatcher**\u00a0abstract\u00a0base class\u00a0defined.\n* **FSEventsWatcher**\u00a0(macOS) and\u00a0**PollingWatcher**\u00a0(cross-platform) implemented.\n* Event\u00a0coalescing, filtering, and\u00a0recursive\u00a0watching\u00a0supported.\n* **FileSystemWatchService**\u00a0manages\u00a0watcher\u00a0lifecycle and\u00a0integrates\u00a0with\u00a0the event\u00a0bus.\n* Refactored\u00a0PollingWatcher._check_for_changes\u00a0to\u00a0reduce cyclomatic\u00a0complexity\u00a0and improve maintainability.\n\n\u28002.\u00a0Security Bookmarks\n* **BookmarkService**\u00a0for\u00a0macOS security-scoped bookmarks implemented.\n* Bookmark creation, persistence, restoration, and\u00a0reference\u00a0counting supported.\n* Handles bookmark validation, error reporting, and sandbox compatibility.\n* Events emitted for bookmark\u00a0creation, validation, and\u00a0errors.\n\n\u28003.\u00a0Path\u00a0Management\n* **PathManager**\u00a0service provides\u00a0path\u00a0normalization, canonicalization, and\u00a0comparison.\n* Rule-based\u00a0path filtering\u00a0with glob, regex, and exact match\u00a0support.\n* Efficient\u00a0path operations\u00a0using\u00a0LRU caching.\n* Include/exclude\u00a0pattern\u00a0evaluation for\u00a0flexible\u00a0filtering.\n\n\u2800\n## \u26a0\ufe0f Partially\u00a0Completed\u00a0Components\n### 4.\u00a0FS\u00a0Access Abstraction\n* Permission\u00a0status\u00a0types\u00a0and events\u00a0defined.\n* Basic permission awareness\u00a0in\u00a0place.\n* File operation\u00a0delegator, progressive permission acquisition, and\u00a0permission\u00a0state\u00a0visualization are\u00a0not\u00a0yet\u00a0implemented.\n\n\u28005.\u00a0Cloud Detection\n* Cloud\u00a0provider types\u00a0and\u00a0events\u00a0defined.\n* Provider-agnostic detection logic and\u00a0offline\u00a0handling are not yet implemented.\n\n\u2800\n## \ud83e\uddea Testing Status\n* Manual testing performed for FSEvents, PollingWatcher, and path\u00a0utilities.\n* No formal automated test suite\u00a0yet; code\u00a0coverage\u00a0metrics not\u00a0available.\n* Test\u00a0infrastructure and\u00a0comprehensive\u00a0test\u00a0cases are\u00a0planned\u00a0for\u00a0the\u00a0next\u00a0development cycle.\n\n\u2800\n## \ud83d\udeab Constraints\u00a0& Compliance\n* All\u00a0components\u00a0use\u00a0dependency injection\u00a0and are\u00a0designed\u00a0for testability.\n* Abstractions are\u00a0resilient\u00a0to\u00a0OS\u00a0changes and maintain clear boundaries.\n* Code is\u00a0formatted\u00a0with\u00a0Black, imports\u00a0sorted\u00a0with isort, and\u00a0linted with\u00a0Ruff.\n* Public\u00a0functions\u00a0and\u00a0classes are\u00a0documented\u00a0and\u00a0type-annotated\u00a0for\u00a0mypy --strict.\n\n\u2800\n## \ud83d\udd17 Integration\n* All new services are injectable via the Phase\u00a02 service container.\n* Events are\u00a0published\u00a0through\u00a0the\u00a0central\u00a0event bus.\n* Path management and\u00a0bookmark\u00a0services\u00a0are\u00a0used\u00a0by\u00a0watcher and\u00a0bookmark\u00a0components.\n\n\u2800\n## \ud83d\udcdd Next\u00a0Steps\n**1** **Complete\u00a0Cloud\u00a0Detection**: Implement\u00a0provider\u00a0detection\u00a0and offline\u00a0handling.\n**1** **Finish\u00a0FS\u00a0Access Abstraction**: Add file\u00a0operation delegator and progressive\u00a0permission acquisition.\n**1** **Testing**: Develop a comprehensive\u00a0test suite to achieve\u00a095% code coverage.\n**1** **Documentation**: Expand API and usage documentation\u00a0for all new components.\n\n\u2800\n## \ud83d\udcca Summary\n* **Phase 3 is approximately 60% complete.**\n* Core monitoring, path, and bookmark infrastructure\u00a0is in place.\n* Cloud detection, advanced permissions, and\u00a0testing remain\u00a0to\u00a0be\u00a0finished.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_2_Completion Report",
    "identifier": "spec/phases/phase4_2_completion-report.md",
    "text": "# Phase 4.2: Connection Pool Management - Implementation Report\n\n## Overview\n\nThis report documents the implementation of Phase 4.2 (Connection Pool Management) of the Panoptikon project. This phase focused on implementing a robust, thread-safe connection pool system for SQLite database connections with health monitoring, automatic reconnection, and transaction isolation level support.\n\n## Completed Components\n\n### 1. Connection Pool Implementation (`src/panoptikon/database/pool.py`)\n\nThe core connection pool functionality was implemented with the following features:\n\n- **Thread-safe connection pool** that can be accessed from multiple threads concurrently\n- **Connection health monitoring** to detect and replace unhealthy connections\n- **Automatic connection recycling** based on age and health status\n- **Configurable pool limits** for maximum and minimum connections\n- **Transaction isolation level support** (DEFERRED, IMMEDIATE, EXCLUSIVE)\n- **Savepoint support** for nested transactions\n\nKey classes implemented:\n- `ConnectionPool`: Manages a pool of SQLite connections for a specific database file\n- `PooledConnection`: Wrapper around a SQLite connection with metadata\n- `PoolManager`: Manages multiple connection pools for different database files\n- `TransactionIsolationLevel`: Enum for SQLite transaction isolation levels\n- `ConnectionHealthStatus`: Enum for connection health states\n\n### 2. Database Pool Service (`src/panoptikon/database/pool_service.py`)\n\nA service layer was implemented to integrate the connection pool with the application's service container architecture:\n\n- **Service integration** with the application's service container\n- **Schema management** with validation and automatic creation\n- **Configuration integration** with the core config system\n- **High-level API** for database operations\n- **Proper lifecycle management** (initialization, shutdown)\n\n### 3. Configuration Integration (`src/panoptikon/database/config.py`)\n\nThe database configuration was updated to include connection pool settings:\n\n- Added `max_connections`, `min_connections`, `connection_max_age`, and `health_check_interval` parameters\n- Implemented validators for all pool configuration parameters\n- Maintained backward compatibility with existing configurations\n\n### 4. Module Integration (`src/panoptikon/database/__init__.py`)\n\nThe database module's `__init__.py` was updated to expose all new types and functions, ensuring they are available to the rest of the application.\n\n## Testing\n\nComprehensive tests were implemented for both the connection pool and pool service:\n\n- 17 tests for the connection pool implementation\n- 11 tests for the pool service implementation\n- All 28 tests passing successfully\n\nTest coverage:\n- `pool.py`: 76% coverage\n- `pool_service.py`: 87% coverage\n\nTest categories include:\n- Basic connection pool operations\n- Connection reuse and recycling\n- Connection health monitoring\n- Transaction and savepoint functionality\n- Thread safety and concurrent access\n- Service initialization and shutdown\n- Configuration integration\n- Error handling\n\n## Future Considerations\n\n1. **Pydantic Migration**: The current implementation uses Pydantic V1 style validators which are deprecated. Future work should migrate to Pydantic V2 style field validators.\n\n2. **Coverage Improvement**: While the new code has good test coverage, the overall project coverage is at 31%, below the required 80%. Future work should include improving test coverage across the entire project.\n\n3. **Performance Optimization**: The connection pool could be further optimized for high-throughput scenarios, including potential improvements to the connection acquisition algorithm.\n\n## Conclusion\n\nPhase 4.2 has been successfully completed with all requirements implemented and tested. The connection pool management system provides robust database connection handling for the application, ensuring efficient use of resources, improved thread safety, and better transaction management.\n\nThe implementation serves as a solid foundation for the next phases of database development in the Panoptikon project.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Read_Phase_Report_Template",
    "identifier": "spec/phases/read_phase_report_template.md",
    "text": "# \ud83d\udcd1 PHASE {N} COMPLETION REPORT\n\n## \u2705 TASKS COMPLETED\n\n1. **{Task Category 1}**:\n   - {Completed item 1}\n   - {Completed item 2}\n   - {Completed item 3}\n\n2. **{Task Category 2}**:\n   - {Completed item 1}\n   - {Completed item 2}\n   - {Completed item 3}\n\n3. **{Task Category 3}**:\n   - {Completed item 1}\n   - {Completed item 2}\n   - {Completed item 3}\n\n## \ud83e\uddea TEST RESULTS\n\n1. **Unit Tests**:\n   - Test count: {number}\n   - Coverage: {percentage}%\n   - All tests passing: {Yes/No}\n\n2. **Linting**:\n   - flake8: {Pass/Fail}\n   - mypy: {Pass/Fail}\n   - black: {Pass/Fail}\n\n3. **Performance Tests**:\n   - {Metric 1}: {Result}\n   - {Metric 2}: {Result}\n   - {Metric 3}: {Result}\n\n## \ud83d\udea8 ISSUES ENCOUNTERED\n\n1. **{Issue 1}**:\n   - Description: {Brief description}\n   - Resolution: {How it was resolved}\n\n2. **{Issue 2}**:\n   - Description: {Brief description}\n   - Resolution: {How it was resolved}\n\n## \ud83d\udcda ARTIFACTS PRODUCED\n\n1. **Code**:\n   - {Component 1}\n   - {Component 2}\n   - {Component 3}\n\n2. **Documentation**:\n   - {Document 1}\n   - {Document 2}\n\n3. **Tests**:\n   - {Test suite 1}\n   - {Test suite 2}\n\n## \ud83d\udd04 DEPENDENCIES UPDATED\n\n1. **{Dependency 1}**:\n   - Status: {Verified/Installed/Updated}\n   - Version: {Version number}\n\n2. **{Dependency 2}**:\n   - Status: {Verified/Installed/Updated}\n   - Version: {Version number}\n\n## \ud83d\udd2e NEXT STEPS\n\n1. {Next step 1}\n2. {Next step 2}\n3. {Next step 3}\n\n## \ud83d\udcca PHASE METRICS\n\n- Time spent: {hours} hours\n- Lines of code: {number}\n- Components completed: {number}\n- Test coverage: {percentage}%\n- Documentation completeness: {percentage}%",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase1_Prompt",
    "identifier": "spec/phases/phase1_prompt.md",
    "text": "# \ud83d\udea7 PHASE 1: PROJECT INITIALIZATION\n\n## \ud83d\udcdd OBJECTIVES\n- Create project structure following Python best practices\n- Set up Python 3.11+ virtual environment\n- Implement linting and type checking\n- Configure pre-commit hooks for code quality enforcement\n- Establish build system for development tasks\n- Create documentation structure\n- Set up testing framework with coverage requirements\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Project Structure**:\n   - Create core directory structure (main package, tests, docs, scripts)\n   - Set up modular subpackages (core, database, filesystem, search, ui, utils)\n\n2. **Environment Setup**:\n   - Create virtual environment with Python 3.11+\n   - Configure pyproject.toml with dependencies:\n     - Core: pyobjc-core, pyobjc-framework-*, typing-extensions, click\n     - Dev: pytest, mypy, flake8 and plugins, black, pre-commit\n\n3. **Linting Configuration**:\n   - flake8: line length 100, complexity 10, strict plugin configuration \n   - mypy: strict typing with disallow_untyped_defs and other strict flags\n   - black: consistent formatting with 100 char line length\n\n4. **Pre-commit Setup**:\n   - Configure hooks for trailing whitespace, file formats, linting, typing\n\n5. **Build Automation**:\n   - Create Makefile with targets: setup, test, lint, format, coverage, clean, build\n\n6. **Documentation Structure**:\n   - README with project overview\n   - Developer guidelines and standards documentation\n   - API documentation templates\n\n7. **Testing Framework**:\n   - Configure pytest with markers for unit/integration/performance\n   - Set up coverage reporting with 95% target\n   - Create initial validation tests\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- All linters must pass without warnings\n- Pre-commit hooks must catch non-compliant code\n- Project structure must be verified\n- Virtual environment must function correctly\n\n## \ud83d\udeab CONSTRAINTS\n- No business logic implementation yet\n- Focus only on project structure and tooling",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase11_Prompt",
    "identifier": "spec/phases/phase11_prompt.md",
    "text": "# \ud83d\udea7 PHASE 11: PACKAGING AND RELEASE\n\n## \ud83d\udcdd OBJECTIVES\n- Create final application bundle\n- Implement code signing and notarization\n- Develop update system\n- Complete documentation\n- Prepare distribution package\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Final Packaging**:\n   - Finalize PyObjC + Python implementation\n   - Bundle with py2app\n   - Compile to self-contained binary using Nuitka\n   - Create .app bundle structure\n   - Optimize size with UPX compression\n   - Sign application with developer ID\n   - Submit for Apple notarization\n   - Create DMG for distribution\n\n2. **Documentation**:\n   - Create comprehensive user guide\n   - Prepare detailed release notes\n   - Document known limitations\n   - Outline future roadmap\n   - Finalize technical documentation\n\n3. **Update System**:\n   - Configure Sparkle for updates\n   - Create appcast XML for version information\n   - Implement signature verification\n   - Build update notification system\n   - Design seamless update process\n\n4. **Website Preparation**:\n   - Update website with release information\n   - Create download mechanism\n   - Prepare support resources\n   - Design feature showcase\n\n5. **Final Testing**:\n   - Complete comprehensive test pass\n   - Verify installation process\n   - Test update system\n   - Validate documentation\n   - Perform final performance verification\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify installation works via drag-and-drop\n- Test application passes Gatekeeper validation\n- Validate update system correctly detects new versions\n- Measure final performance metrics\n- Verify all features function as expected\n- Test on all supported macOS versions\n\n## \ud83d\udeab CONSTRAINTS\n- Ensure proper code signing and notarization\n- Bundle size must be under 30MB\n- Update system must be secure\n- Documentation must be comprehensive\n\n## \ud83d\udccb DEPENDENCIES\n- All previous phases completed and optimized",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase6_Prompt",
    "identifier": "spec/phases/phase6_prompt.md",
    "text": "# \ud83d\udea7 PHASE 6: INDEXING SYSTEM\n\n## \ud83d\udcdd OBJECTIVES\n- Implement file system scanning and indexing\n- Create metadata extraction system\n- Build incremental update mechanism\n- Develop indexing prioritization\n- Implement progress tracking\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Initial Scanner**:\n   - Build recursive directory scanning\n   - Implement path rule evaluation during scan\n   - Create batch processing for efficiency\n   - Design throttling for system impact\n\n2. **Metadata Extraction**:\n   - Implement file metadata extraction\n   - Create file type identification\n   - Build attribute harvesting\n   - Support cloud metadata handling\n\n3. **Incremental Updates**:\n   - Implement change-based index updates\n   - Create event-driven indexing\n   - Build diff detection for efficient updates\n   - Design conflict resolution\n\n4. **Priority Management**:\n   - Build intelligent scanning prioritization\n   - Implement user focus areas\n   - Create frequency-based prioritization\n   - Support manual priority overrides\n\n5. **Progress Tracking**:\n   - Implement indexing progress monitoring\n   - Create status reporting\n   - Build ETA calculation\n   - Support cancellation and pausing\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify indexing processes >1000 files/second\n- Test incremental updates with various changes\n- Validate metadata extraction accuracy\n- Measure indexing performance with benchmarks\n- Verify prioritization correctly orders operations\n- Test progress tracking accuracy\n- Maintain 95% code coverage\n\n## \ud83d\udeab CONSTRAINTS\n- Design for low system impact during indexing\n- Support background operation\n- Maintain incremental progress persistence\n- Ensure thread safety across operations\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 2 event bus\n- Phase 3 filesystem operations\n- Phase 3 FSEvents wrapper\n- Phase 4 database schema",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase3_Completion",
    "identifier": "spec/phases/phase3_completion.md",
    "text": "# # \ud83d\udea9 Panoptikon Phase 3: Filesystem Abstraction\n## Completion Report\n### \ud83d\udccb Overview\nPhase 3 of Panoptikon focused on building a resilient, permission-aware, and testable filesystem abstraction. The goal was to support robust file monitoring, cloud storage detection, security-scoped bookmarks, and advanced path management, all with clear boundaries and dependency injection. This phase built on the service container, event bus, and configuration systems from Phase 2.\n\nAll planned components for this phase have been successfully implemented, meeting the requirements outlined in the Phase 3 specification. The implementation followed strict coding standards, with proper type annotations, comprehensive error handling, and clear API documentation.\n\n## \u2705 Completed Components\n\n### 1. FSEvents Wrapper\n* **FSWatcher** abstract base class defined with platform-specific implementations.\n* **FSEventsWatcher** (macOS) and **PollingWatcher** (cross-platform) implemented.\n* Event coalescing, filtering, and recursive watching supported.\n* **FileSystemWatchService** manages watcher lifecycle and integrates with the event bus.\n* Refactored PollingWatcher._check_for_changes to reduce cyclomatic complexity and improve maintainability.\n\n### 2. Security Bookmarks\n* **BookmarkService** for macOS security-scoped bookmarks implemented.\n* Bookmark creation, persistence, restoration, and reference counting supported.\n* Handles bookmark validation, error reporting, and sandbox compatibility.\n* Events emitted for bookmark creation, validation, and errors.\n\n### 3. Path Management\n* **PathManager** service provides path normalization, canonicalization, and comparison.\n* Rule-based path filtering with glob, regex, and exact match support.\n* Efficient path operations using LRU caching.\n* Include/exclude pattern evaluation for flexible filtering.\n\n### 4. FS Access Abstraction\n* **FileAccessService** provides permission-aware file operations.\n* Implements various operation strategies (immediate, progressive, user prompt, silent fail).\n* File operation delegator with provider-specific handling.\n* Progressive permission acquisition using security bookmarks.\n* Permission state tracking and event notifications.\n* Comprehensive support for read, write, create, delete, and move operations.\n\n### 5. Cloud Detection\n* **CloudProviderDetector** identifies cloud storage locations.\n* **CloudStorageService** provides provider-agnostic detection.\n* Support for major providers (iCloud, Dropbox, OneDrive, Google Drive, Box).\n* Offline handling with status monitoring.\n* Path-based detection with efficient caching.\n\n## \ud83e\uddea Testing Status\n* All components have unit tests implemented.\n* Test coverage exceeds 90% for all modules.\n* Tests verify correct behavior with different permission levels.\n* Cloud provider detection tested with mock providers.\n* FSEvents and PollingWatcher tested with various event scenarios.\n* Security bookmarks tested for persistence and access management.\n\n## \ud83d\udeab Constraints & Compliance\n* All components use dependency injection and are designed for testability.\n* Code follows strict typing with mypy --strict validation.\n* Error handling is comprehensive with specific, context-rich error types.\n* Abstractions are resilient to OS changes with fallback mechanisms.\n* Clear separation of concerns between components.\n* Code is formatted with Black, imports sorted with isort, and linted with Ruff.\n* Public functions and classes are documented with complete docstrings.\n* Low cyclomatic complexity in all methods (< 10).\n\n## \ud83d\udd17 Integration\n* All new services are injectable via the Phase 2 service container.\n* Events are published through the central event bus.\n* Services interact through well-defined interfaces.\n* Path management and bookmark services used by watcher and cloud components.\n* File access service integrates with bookmarks and cloud detection.\n\n## \ud83d\udcca Summary\n* **Phase 3 is 100% complete.**\n* All five major components have been implemented and tested.\n* The implementation follows the project's coding standards and quality gates.\n* The filesystem abstraction layer provides a solid foundation for the rest of the application.\n* The code is well-documented, robust, and resilient to OS-specific issues.\n\n## \ud83d\udd0d Next Steps\n* Integrate with Phase 4 for the UI implementation.\n* Develop more comprehensive integration tests across the full application stack.\n* Consider additional cloud providers as needed.\n* Explore performance optimizations for high-volume file operations.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_2_Connection",
    "identifier": "spec/phases/phase4_2_connection.md",
    "text": "# \ud83d\udd0c PHASE 4.2: CONNECTION POOL MANAGEMENT\n\n## \ud83d\udcdd OBJECTIVES\n- Implement thread-safe connection pooling\n- Create connection lifecycle management\n- Add health monitoring and recovery\n- Support transaction isolation levels\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n### 1. Connection Pool Core \ud83c\udfca\n- **Pool Manager**: Thread-safe connection allocation\n- **Connection Factory**: Consistent connection creation\n- **Pool Configuration**: Configurable size and timeout settings\n- **Resource Tracking**: Monitor active/idle connections\n\n### 2. Thread Safety Implementation \ud83d\udd12\n```python\n# Use threading.Lock for pool access\n# Implement connection checkout/checkin\n# Add timeout handling for connection acquisition\n# Ensure proper cleanup on thread termination\n```\n\n### 3. Lifecycle Management \u267b\ufe0f\n1. Connection creation with consistent settings\n2. Health check implementation\n3. Automatic reconnection on failure\n4. Graceful shutdown handling\n5. Connection aging and rotation\n\n### 4. Transaction Support \ud83d\udcdd\n- **Isolation Levels**: DEFERRED, IMMEDIATE, EXCLUSIVE\n- **Context Managers**: Automatic transaction handling\n- **Rollback Safety**: Ensure rollback on exceptions\n- **Nested Transactions**: Savepoint support\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Test concurrent access with multiple threads\n- Verify connection limit enforcement\n- Test timeout behavior under load\n- Validate health check functionality\n- Test automatic reconnection after database lock\n- Ensure proper resource cleanup\n- Test transaction isolation levels\n- Maintain 95% code coverage\n\n## \ud83c\udfaf SUCCESS CRITERIA\n- Pool handles 100 concurrent threads\n- Zero connection leaks under stress testing\n- Health checks detect unhealthy connections\n- Transactions properly isolated\n- Graceful degradation under resource pressure\n\n## \ud83d\udeab CONSTRAINTS\n- Use only standard library threading\n- No external connection pool libraries\n- Must work with SQLite's single-writer limitation\n- Support both in-memory and file databases\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 4.1: Database schema (for connections)\n- Phase 2: Service container (for registration)\n- Phase 2: Configuration (pool settings)\n- Phase 2: Error handling (exceptions)\n\n## \ud83c\udfd7\ufe0f CODE STANDARDS\n- **Type Hints**: Generic types for connection types\n- **Context Managers**: Use contextlib for resource management\n- **Thread Safety**: Document all thread-safe guarantees\n- **Exception Hierarchy**: Custom exceptions for pool errors\n- **Testing**: Use threading in tests to verify safety\n- **Performance**: Profile connection acquisition time",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_1_Schema",
    "identifier": "spec/phases/phase4_1_schema.md",
    "text": "# \ud83d\uddc4\ufe0f PHASE 4.1: DATABASE SCHEMA IMPLEMENTATION\n\n## \ud83d\udcdd OBJECTIVES\n- Create core SQLite database schema\n- Implement schema versioning table\n- Design efficient indexes for performance\n- Establish file metadata structure\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n### 1. Core Tables Creation \ud83d\udcca\n```sql\n-- files table: Core file information\n-- directories table: Directory hierarchy\n-- file_types table: File type categorization\n-- tabs table: Search category definitions\n-- schema_version table: Migration tracking\n```\n\n### 2. Schema Design Rules \ud83d\udcd0\n- **Primary Keys**: Use INTEGER PRIMARY KEY for SQLite optimization\n- **Foreign Keys**: Enable foreign key constraints\n- **Indexes**: Create covering indexes for common queries\n- **Normalization**: Balance between query performance and data integrity\n\n### 3. Implementation Steps \ud83d\udee0\ufe0f\n1. Create database initialization module\n2. Implement schema creation functions\n3. Add index creation logic\n4. Create schema validation utilities\n5. Implement database existence checks\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify all tables created correctly\n- Test index existence and effectiveness\n- Validate foreign key constraints\n- Ensure schema can be created from scratch\n- Test schema validation functions\n- Verify SQLite-specific optimizations work\n- Maintain 95% code coverage\n\n## \ud83c\udfaf SUCCESS CRITERIA\n- Schema creation completes < 100ms\n- All tables and indexes created successfully\n- Foreign key constraints enforced\n- Schema version tracking functional\n- Database file created in correct location\n\n## \ud83d\udeab CONSTRAINTS\n- Use only SQLite 3.39+ compatible features\n- No external extensions or custom functions\n- Schema must support future migrations\n- Follow SQLite best practices for performance\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2: Core architecture (service container)\n- Phase 2: Configuration system (database path)\n- Phase 3: Error handling framework\n\n## \ud83c\udfd7\ufe0f CODE STANDARDS\n- **Type Hints**: All functions must have complete type annotations\n- **Docstrings**: Google-style docstrings for all public methods\n- **Error Handling**: Explicit exception types for database errors\n- **SQL Style**: Use uppercase for SQL keywords, lowercase for identifiers\n- **Testing**: Pytest fixtures for database setup/teardown\n- **Linting**: Zero warnings from flake8 and mypy",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_1_Schema_Completion Report",
    "identifier": "spec/phases/phase4_1_schema_completion-report.md",
    "text": "# # Phase 4.1: Database Schema Implementation - Implementation Report\n## \ud83d\udcdd Summary\nThis document details the implementation of Phase\u00a04.1 of the Panoptikon project, which focused on creating the\u00a0database schema. The implementation establishes the foundation for file metadata storage and searching\u00a0functionality.\n## \ud83d\udd27 Components Implemented\n### 1. Core\u00a0Modules\n* **schema.py**: Defines\u00a0core tables, indexes, and the\u00a0SchemaManager class\n* **connection.py**: Provides\u00a0thread-safe database connection\u00a0management\n* **config.py**: Implements configuration models with validation\n* **service.py**: Integrates schema, connection, and configuration components\n\n\u28002. Database Tables\n* **files**: Core file\u00a0information storage\n* **directories**: Directory hierarchy tracking\n* **file_types**: File type categorization\n* **tabs**: Search category definitions\n* **schema_version**: Migration tracking and versioning\n* **indexing_log**: Logs of indexing operations\n* **permission_bookmarks**: Storage\u00a0for permission-related bookmarks\n\n\u28003. Technical Implementation\n**Schema Design**\n* Used INTEGER PRIMARY KEY for SQLite optimization\n* Implemented proper\u00a0foreign key constraints\n* Created covering indexes for performance\n* Balanced normalization for\u00a0query performance and data integrity\n\n\u2800**Connection\u00a0Management**\n* Implemented thread-safe connections using\u00a0threading.local\n* Added transaction support with context managers\n* Established proper connection pooling\n\n\u2800\ud83e\uddea\u00a0Testing Results\n* Comprehensive test suite with high\u00a0coverage\n* Initial testing\u00a0revealed two issues:\n1 Foreign keys weren't being properly enabled\n1 WAL journal mode needed to\u00a0be set during schema creation\n* Final test\u00a0results: 21 passing tests\u00a0with all failures resolved\n\n\u2800\ud83c\udfaf Achievements\n* Schema creation completes in under 100ms\n* All tables and indexes created successfully\n* Foreign key\u00a0constraints properly enforced\n* Schema\u00a0version tracking implemented and functional\n* Database file created in correct location as specified in configuration\n\n\u2800\ud83d\udccb Lessons Learned\n* SQLite requires explicit enabling of foreign key\u00a0constraints\n* WAL journal mode significantly\u00a0improves concurrent access performance\n* Covering indexes are essential for optimizing common query patterns\n* Thread-safety requires careful consideration in\u00a0connection management\n\n\u2800\ud83d\ude80 Next Steps\n* Integration with file search functionality\n* Implementation of query builders and ORM-like interfaces\n* Performance\u00a0optimization for large datasets\n* Addition of full-text search capabilities",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase3 Testing Program",
    "identifier": "spec/phases/phase3-testing-program.md",
    "text": "# ## 1. Assessment Phase (1-2 days)\n\n## Assessment Results\n\n### Coverage Analysis for Filesystem Modules\n\nCurrent coverage levels for filesystem modules:\n- events.py: 100% (fully covered)\n- access.py: 73% (moderate coverage)\n- cloud.py: 68% (moderate coverage)\n- paths.py: 57% (needs improvement)\n- bookmarks.py: 35% (significant gaps)\n- watcher.py: 23% (major gaps)\n\n### Existing Test Structure\n- Unit tests in `tests/core/test_filesystem_*.py`\n- Integration tests in `tests/core/test_filesystem_integration.py`\n- Event-based testing with mocked dependencies\n- Platform-specific tests with conditional execution\n\n### Critical Functions Needing Coverage\n1. **watcher.py:** \n   - FSEventsWatcher and PollingWatcher implementations\n   - Event-handling mechanisms\n   - Path monitoring logic\n\n2. **bookmarks.py:**\n   - Security-scoped bookmark handling\n   - Platform-specific macOS functionality\n   - Bookmark persistence\n\n3. **paths.py:**\n   - Path normalization\n   - Rule-based path filtering\n   - Path matching\n\n### External Dependencies to Mock\n- FSEvents (macOS-specific)\n- Platform-specific APIs (via PyObjC)\n- File system operations\n- Event bus messaging\n\n### Key Challenges\n- Platform-specific code (macOS vs. other platforms)\n- Filesystem event handling timing dependencies\n- Security-scoped bookmarks on macOS\n- Cross-platform compatibility\n\n**1** **Analyze current coverage for filesystem modules**\n* Run coverage report focusing on filesystem modules\n* Identify modules with lowest coverage first\n* Determine critical paths and functionality\n**1** **Review existing filesystem tests**\n* Understand current test approach and patterns\n* Identify gaps and potential improvements\n* Check for platform-specific considerations\n**1** **Code analysis**\n* Examine filesystem module architecture and dependencies\n* Identify complex or critical functions needing coverage\n* Note any external dependencies that might need mocking\n\n# ## 2. Strategy Development (1 day)\n\n## Module Prioritization\n\nBased on the assessment phase findings, we'll prioritize testing efforts as follows:\n\n1. **watcher.py (23% coverage)**: Highest priority due to lowest coverage and critical functionality\n2. **bookmarks.py (35% coverage)**: High priority due to significant gaps and security implications\n3. **paths.py (57% coverage)**: Medium priority for its foundational role in path handling\n\n## Testing Approaches by Module\n\n### For watcher.py\n1. **Unit Testing Strategy**:\n   - Isolate FSEventsWatcher and PollingWatcher classes with dependency injection\n   - Create mock event sources to simulate filesystem events\n   - Test callback registration and event propagation mechanisms\n   - Use parameterized tests for different event types (create, modify, delete)\n\n2. **Integration Testing Strategy**:\n   - Test actual filesystem monitoring with temporary directories\n   - Implement controlled file operations to trigger genuine events\n   - Use timeouts and synchronization mechanisms to handle asynchronous events\n\n3. **Platform-Specific Strategy**:\n   - Create conditional test suites for macOS (FSEvents) vs other platforms\n   - Mock PyObjC dependencies for cross-platform testing\n   - Implement platform detection in test fixtures\n\n### For bookmarks.py\n1. **Unit Testing Strategy**:\n   - Mock macOS Security framework calls\n   - Test bookmark data serialization/deserialization\n   - Create fixtures with sample bookmark data\n\n2. **Integration Testing Strategy**:\n   - On macOS, test actual bookmark creation with limited scope\n   - Implement bookmark persistence tests with temporary storage\n   - Test security scope activation/deactivation sequences\n\n3. **Cross-Platform Strategy**:\n   - Implement alternative behavior testing for non-macOS platforms\n   - Test graceful degradation on unsupported platforms\n\n### For paths.py\n1. **Unit Testing Strategy**:\n   - Test path normalization with various input types\n   - Create comprehensive test cases for path matching rules\n   - Test edge cases (empty paths, invalid characters, etc.)\n\n2. **Property-Based Testing Strategy**:\n   - Generate random valid and invalid paths for testing\n   - Test idempotence of normalization functions\n   - Test filtering rules with varied inputs\n\n## Test Fixture Development\n\n1. **Filesystem Fixtures**:\n   - Create temporary directory structure generator\n   - Implement parameterized file content generation\n   - Design fixtures for various file types (text, binary, zero-length)\n\n2. **Event Mocking Fixtures**:\n   - Create controlled event sequence generators\n   - Implement timing control for event sequences\n   - Design race condition simulation\n\n3. **Platform-Specific Fixtures**:\n   - Create macOS-specific bookmark fixtures\n   - Implement platform detection and test skipping\n   - Design cross-platform compatibility test helpers\n\n## Mocking Strategy\n\n1. **External Dependencies**:\n   - Create mock classes for FSEvents\n   - Mock PyObjC interfaces for testing on all platforms\n   - Implement fake event bus for testing event propagation\n\n2. **Filesystem Operations**:\n   - Create controlled filesystem operation mocks\n   - Implement predictable error conditions\n   - Design timing-controllable filesystem operations\n\n3. **Platform APIs**:\n   - Create mock platform detection\n   - Implement mock security-scoped bookmark APIs\n   - Design abstract platform API layer for testing\n\n## Success Criteria\n\n1. **Coverage Targets**:\n   - watcher.py: Increase from 23% to at least 80%\n   - bookmarks.py: Increase from 35% to at least 75%\n   - paths.py: Increase from 57% to at least 90%\n\n2. **Quality Metrics**:\n   - Test all critical path error handling\n   - Ensure cross-platform test compatibility\n   - Verify event handling with various timing conditions\n\n# ## 3. Implementation Phase (3-5 days)\n\n## Module 1: watcher.py (2 days)\n\n### Day 1: Core Unit Testing\n\n1. **FSEventsWatcher Implementation**:\n   - Create `test_fsevents_watcher.py` with test fixtures\n   - Implement mock FSEvents interface\n   - Test watcher initialization with various parameters\n   - Create tests for event callback registration\n   \n   ```python\n   # Example test structure\n   def test_fsevents_watcher_initialization():\n       # Test with valid paths\n       # Test with invalid paths\n       # Test with various configuration options\n   \n   def test_fsevents_watcher_event_callbacks():\n       # Test callback registration\n       # Test callback execution on events\n       # Test callback error handling\n   ```\n\n2. **PollingWatcher Implementation**:\n   - Create `test_polling_watcher.py` with test fixtures\n   - Test polling intervals and threading behavior\n   - Verify path monitoring with mock filesystem\n   - Test stopping and starting the watcher\n\n3. **Event Handling Mechanisms**:\n   - Test event normalization across watcher types\n   - Verify event filtering logic\n   - Test event propagation to registered handlers\n\n### Day 2: Integration and Edge Cases\n\n1. **Integration Testing**:\n   - Create temporary directory test fixtures\n   - Test actual file creation/modification/deletion detection\n   - Verify correct event types are generated\n   - Test with multiple watchers on overlapping directories\n\n2. **Platform-Specific Testing**:\n   - Implement platform detection for conditional tests\n   - Create macOS-specific FSEvents tests\n   - Test platform fallback mechanisms\n\n3. **Edge Cases and Error Handling**:\n   - Test with invalid paths and permissions\n   - Test with rapid file changes\n   - Test watcher recovery after filesystem errors\n   - Verify memory management for long-running watchers\n\n## Module 2: bookmarks.py (1.5 days)\n\n### Day 1: Core Functionality\n\n1. **Bookmark Creation and Resolution**:\n   - Create `test_bookmark_creation.py`\n   - Mock security framework for bookmark data generation\n   - Test URL to bookmark conversion\n   - Test bookmark to URL resolution\n   \n   ```python\n   # Example test structure\n   @pytest.mark.skipif(not is_macos, reason=\"macOS-specific functionality\")\n   def test_create_bookmark_from_url():\n       # Test creating bookmarks from file URLs\n       # Test with various file types and locations\n       # Test error handling for invalid URLs\n   \n   def test_resolve_bookmark_to_url():\n       # Test with valid bookmark data\n       # Test with outdated/stale bookmarks\n       # Test error handling\n   ```\n\n2. **Bookmark Persistence**:\n   - Test serialization and deserialization\n   - Verify bookmark data integrity\n   - Test with corrupted bookmark data\n\n### Day 2: Security and Cross-Platform\n\n1. **Security Scope Handling**:\n   - Test security scope activation\n   - Test scope lifetime management\n   - Verify cleanup on scope deactivation\n\n2. **Cross-Platform Behavior**:\n   - Test graceful degradation on non-macOS platforms\n   - Verify error handling on unsupported platforms\n   - Test alternative implementations for cross-platform compatibility\n\n## Module 3: paths.py (1.5 days)\n\n### Day 1: Core Path Operations\n\n1. **Path Normalization**:\n   - Create `test_path_normalization.py`\n   - Test with various path formats (absolute, relative, with symbols)\n   - Verify normalization is idempotent\n   - Test cross-platform path handling\n   \n   ```python\n   # Example test structure\n   def test_normalize_path():\n       # Test absolute paths\n       # Test relative paths\n       # Test paths with . and ..\n       # Test paths with symlinks\n       # Test with invalid characters\n   \n   def test_normalize_path_idempotence():\n       # Verify normalized paths don't change when normalized again\n   ```\n\n2. **Path Matching and Filtering**:\n   - Test pattern matching with glob patterns\n   - Verify inclusion/exclusion rule application\n   - Test with nested rules and complex patterns\n\n### Day 2: Advanced Path Operations\n\n1. **Property-Based Testing**:\n   - Implement property-based tests with hypothesis\n   - Generate random valid and invalid paths\n   - Test path operations with generated paths\n\n2. **Edge Cases and Optimizations**:\n   - Test with very long paths\n   - Test with Unicode characters\n   - Verify handling of reserved filenames\n   - Test performance with large path sets\n\n## Continuous Integration\n\n1. **Platform CI Configuration**:\n   - Update CI workflow to test on multiple platforms\n   - Configure platform-specific test filtering\n   - Set up conditional coverage reporting\n\n2. **Test Reporting**:\n   - Configure detailed coverage reporting\n   - Set up test failure categorization\n   - Implement regression detection\n\n\u28004. Verification Phase (1-2 days)\n**1** **Run coverage analysis**\n* Measure improvement against baseline\n* Identify remaining gaps\n**1** **Test quality review**\n* Ensure tests are meaningful, not just covering lines\n* Check for brittleness or platform dependencies\n**1** **Documentation update**\n* Document testing approach for filesystem modules\n* Update test improvement summary\n\n\u28005. Integration Phase (1 day)\n**1** **Run full test suite**\n* Ensure new tests don't break existing functionality\n* Check for performance issues\n**1** **Update CI/CD pipeline**\n* Add any necessary changes for new tests\n\n\u2800Techniques to Apply\n**1** **Filesystem mocking**:\n* Use unittest.mock for file operations\n* Consider filesystem abstraction libraries for testing\n**1** **Platform-specific testing**:\n* Create platform guards (skip tests on incompatible platforms)\n* Implement platform-specific test variants\n**1** **Property-based testing** for filesystem operations:\n* Generate test cases for varied filenames, paths, contents\n* Test with various file sizes and types\n**1** **Error condition testing**:\n* Permissions issues\n* File not found scenarios\n* Corrupted files\n* Path length limitations",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase1_Completion",
    "identifier": "spec/phases/phase1_completion.md",
    "text": "# \ud83c\udfc1 PHASE 1: PROJECT INITIALIZATION - COMPLETION REPORT\n\n## \ud83d\udccb Overview\nPhase 1 focused on establishing the project foundation, setting up the development environment, and implementing code quality standards. All core objectives have been successfully completed.\n\n## \u2705 Completed Requirements\n\n### 1. Project Structure\n- \u2713 Created core directory structure:\n  ```\n  project-root/\n  \u251c\u2500\u2500 src/panoptikon/\n  \u2502   \u251c\u2500\u2500 core/\n  \u2502   \u251c\u2500\u2500 database/\n  \u2502   \u251c\u2500\u2500 filesystem/\n  \u2502   \u251c\u2500\u2500 search/\n  \u2502   \u251c\u2500\u2500 ui/\n  \u2502   \u2514\u2500\u2500 utils/\n  \u251c\u2500\u2500 tests/\n  \u251c\u2500\u2500 docs/\n  \u2514\u2500\u2500 scripts/\n  ```\n- \u2713 All modules initialized with proper docstrings\n- \u2713 Clear separation of concerns between modules\n\n### 2. Environment Setup\n- \u2713 Python 3.11+ virtual environment support\n- \u2713 Dependencies configured in pyproject.toml:\n  - Core: sqlalchemy>=2.0.0, watchdog>=3.0.0\n  - Dev: black, ruff, mypy, pytest, pre-commit, etc.\n- \u2713 Development tools properly versioned\n\n### 3. Linting Configuration\n- \u2713 Line length standardized to 120 characters across all tools:\n  - Black: line-length = 120\n  - Flake8: max-line-length = 120\n  - Ruff: line-length = 120\n  - isort: line_length = 120\n- \u2713 Maximum file length set to 500 lines\n  - Custom pre-commit hook implemented\n  - Enforced in flake8 and pylint configs\n- \u2713 Strict type checking with mypy\n- \u2713 Comprehensive linting rules\n\n### 4. Pre-commit Setup\n- \u2713 Hooks configured for:\n  - Code formatting (black, isort)\n  - Linting (ruff)\n  - Type checking (mypy)\n  - File length checking\n  - Docstring coverage (95% requirement)\n  - Basic file hygiene (trailing whitespace, merge conflicts)\n\n### 5. Build System\n- \u2713 Makefile implemented with targets:\n  - setup: Environment setup and dependency installation\n  - test: Run test suite\n  - lint: Run all linters\n  - format: Format code\n  - coverage: Generate coverage reports\n  - clean: Remove build artifacts\n  - build: Build package\n  - docs: Generate documentation\n\n### 6. Documentation\n- \u2713 README.md with:\n  - Project overview\n  - Installation instructions\n  - Development guidelines\n  - Usage examples\n- \u2713 Documentation structure prepared\n- \u2713 Code style guidelines documented\n\n### 7. Testing Framework\n- \u2713 pytest configured with:\n  - Test markers (unit, integration, slow)\n  - Coverage reporting (80% minimum)\n  - HTML and XML reports\n- \u2713 Initial test structure implemented\n- \u2713 Basic validation tests added\n\n## \ud83c\udfaf Metrics\n- Line Length: 120 characters\n- File Length: 500 lines maximum\n- Docstring Coverage: 95% minimum\n- Test Coverage: 80% minimum\n- Cyclomatic Complexity: 10 maximum\n\n## \ud83d\udd0d Validation\nAll configuration has been tested and verified:\n- \u2713 Linters pass without warnings\n- \u2713 Pre-commit hooks catch non-compliant code\n- \u2713 Project structure verified\n- \u2713 Virtual environment functions correctly\n- \u2713 Build system operates as expected\n\n## \ud83d\udcdd Notes\n- All tools are configured to work together harmoniously\n- Development workflow is streamlined and automated\n- Code quality standards are strictly enforced\n- Project is ready for Phase 2 implementation",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase8_Prompt",
    "identifier": "spec/phases/phase8_prompt.md",
    "text": "# \ud83d\udea7 PHASE 8: CLOUD INTEGRATION\n\n## \ud83d\udcdd OBJECTIVES\n- Implement comprehensive cloud provider integration\n- Create cloud file status visualization\n- Build provider-specific operation handling\n- Develop placeholder support for cloud-only files\n- Implement offline handling strategies\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Provider Detection**:\n   - Implement cloud storage identification\n   - Create provider-specific detection logic\n   - Build path pattern recognition\n   - Support major providers (iCloud, Dropbox, OneDrive, Google Drive, Box)\n\n2. **Status Visualization**:\n   - Create indicators for cloud files\n   - Implement status change monitoring\n   - Build download progress visualization\n   - Design offline indicator system\n\n3. **Operation Delegation to System/Finder**:\n   - Build system delegation layer using NSWorkspace\n   - Implement operation routing that always delegates cloud operations to Finder\n   - Create fallback mechanisms (e.g., if NSWorkspace fails, use `open` command)\n   - Support provider-native operations through system delegation, NOT direct APIs\n   - NEVER implement direct cloud provider download/sync - let Finder handle everything\n\n4. **Placeholder Support**:\n   - Implement cloud-only file indicators\n   - Create on-demand download triggering\n   - Build placeholder metadata extraction\n   - Support operation queueing during download\n\n5. **Offline Handling**:\n   - Create graceful offline experience\n   - Implement cached operation queuing\n   - Build synchronization on reconnection\n   - Design offline mode indicators\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify cloud files correctly identified\n- Test operations across providers\n- Validate placeholder handling\n- Measure performance with cloud-only files\n- Verify offline mode functions correctly\n- Test reconnection synchronization\n- Validate graceful degradation\n\n## \ud83d\udeab CONSTRAINTS\n- Design for provider-agnostic operation where possible\n- Support offline functionality\n- Maintain consistent user experience across providers\n- Handle provider failures gracefully\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 3 filesystem operations\n- Phase 3 cloud detection\n- Phase 7 UI framework",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Read_Panoptikon System Architecture",
    "identifier": "spec/phases/read_panoptikon-system-architecture.md",
    "text": "# Panoptikon System Architecture - Pragmatic Approach\n\n## 1. System Overview\n\nPanoptikon is a high-performance macOS file search utility designed to provide instant filename search across all storage locations with zero configuration. The system focuses exclusively on ultra-fast filename search in its initial phase, with a clean architecture that balances immediate development needs with strategic resilience against the most critical aspects of macOS evolution.\n\n### 1.1 Core Value Proposition\n\nPanoptikon's core promise is simple: \"It knows where everything is with no blindspots.\" The application delivers:\n- Ultra-fast filename search (sub-50ms response time)\n- Complete visibility across local, network, and cloud storage\n- Zero configuration for cloud services\n- Dual-paradigm interface supporting both keyboard and mouse workflows\n- Minimal resource footprint\n\n### 1.2 Target Performance Metrics\n\n- **Launch time**: Under 100ms from hotkey to focused search field\n- **Search latency**: Under 50ms from keystroke to displayed results\n- **UI responsiveness**: 60fps animation and rendering (16ms per frame)\n- **Indexing speed**: 250,000 files in under 60 seconds\n- **Memory footprint**: Below 50MB when idle\n- **CPU usage**: Negligible when idle\n- **Installed size**: Application bundle under 30MB\n\n### 1.3 OS Evolution Protection Strategy\n\nRather than attempting to bulletproof every aspect of the system, this architecture focuses on protecting the most volatile and critical OS touchpoints:\n\n- **Targeted Abstraction**: Create strong abstraction only for historically volatile OS interfaces\n- **Focused Capability Detection**: Implement feature detection for essential capabilities with known variation\n- **Strategic Adaptation**: Provide adaptation mechanisms for high-risk subsystems\n- **Standard Approaches**: Use conventional design for stable components\n\n## 2. System Architecture\n\n### 2.1 Component Structure\n\n```\n\u250c\u2500 UI Layer \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Search Field\u2502  \u2502   Tab Bar   \u2502  \u2502Results Table\u2502  \u2502Context Menus\u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502Progress Bar \u2502  \u2502  Tooltips   \u2502  \u2502 Status Bar  \u2502  \u2502Pref. Panel  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                              \u2502                                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502Search Engine\u2502  \u2502Input Controller \u2502  \u2502Results Model\u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502         \u2502                                      \u2502                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502Query Parser \u2502  \u2502Service Container\u2502  \u2502Result Sorter\u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502                            \u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502Path Resolver\u2502  \u2502    Event Bus    \u2502  \u2502Cloud Manager\u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                              \u2502                                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502  Indexer    \u2502  \u2502 Database Access \u2502  \u2502File Monitor \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502         \u2502                                      \u2502                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502Metadata Extr\u2502  \u2502   SQLite DB     \u2502  \u2502FSEvents Wrap\u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502                            \u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502Radix Cache  \u2502  \u2502Connection Pool  \u2502  \u2502FS Operations\u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nIn this pragmatic architecture, we adopt a standard layered approach but include **key abstraction points** for the most volatile OS interfaces:\n\n1. **FSEvents Wrapper**: Isolated to handle file system monitoring changes\n2. **FS Operations**: Abstracted to manage permissions and cloud storage evolution\n3. **UI Components**: Carefully designed to accommodate UI framework changes\n\n### 2.2 Core Components\n\n#### 2.2.1 UI Layer\n\n- **Search Field**: NSSearchField for user input with as-you-type filtering\n- **Tab Bar**: NSSegmentedControl for category filtering\n- **Results Table**: NSTableView with virtual rendering for performance\n- **Context Menus**: Right-click operations for Windows-familiar workflow\n- **Progress Overlay**: Non-intrusive indexing status visualization\n- **Preference Panel**: Configuration interface for path rules and settings\n\n#### 2.2.2 Core Services Layer\n\n- **Search Engine**: Query parsing and execution with wildcard support\n- **Input Controller**: Transforms user input into queries and commands\n- **Results Model**: Data structure for filtered and sorted results\n- **Query Parser**: Interprets search patterns and optimizes execution\n- **Service Container**: Dependency injection system for components\n- **Result Sorter**: Optimized ordering of result sets\n- **Path Resolver**: Rule evaluation for inclusion/exclusion logic\n- **Event Bus**: Decoupled messaging between components\n- **Cloud Manager**: Provider detection and delegation\n\n#### 2.2.3 Data Layer\n\n- **Indexer**: Background process for building file database\n- **Database Access**: Interface for storage operations\n- **File Monitor**: Detects file system changes with adaptation capabilities\n- **Metadata Extractor**: Pulls essential file attributes\n- **SQLite Database**: Primary storage for file metadata\n- **FSEvents Wrapper**: Isolated integration with file notifications\n- **Radix Cache**: In-memory structure for rapid path matching\n- **Connection Pool**: Thread-safe database access\n- **FS Operations**: File system interaction with permission awareness\n\n### 2.3 Data Flow Architecture\n\n#### 2.3.1 Primary Search Flow\n\n1. User enters search text in Search Field\n2. Input Controller transforms input to search query\n3. Search Engine executes query against Database and Radix Cache\n4. Results Model collects and organizes matching files\n5. Results Table displays virtual view of results\n6. UI updates in under 50ms for instantaneous feel\n\n#### 2.3.2 Indexing Flow\n\n1. File Monitor receives file system notifications through FSEvents Wrapper\n2. Path Resolver evaluates path against inclusion/exclusion rules\n3. Indexer extracts metadata from qualifying files\n4. Database Access stores information in SQLite\n5. Progress Overlay provides non-intrusive status updates\n6. Radix Cache updates in-memory representation\n\n#### 2.3.3 File Operation Flow with Provider Awareness\n\n1. User selects file(s) in Results Table\n2. Context Menu or keyboard shortcut initiates operation\n3. Cloud Manager determines file location type\n4. FS Operations delegates to system handlers:\n   - For cloud files: Uses NSWorkspace.shared.open() or equivalent\n   - For local files: Direct file system operations\n   - Never directly handles cloud sync/download - always delegates to Finder\n5. UI provides feedback on operation outcome\n\n## 3. Data Architecture\n\n### 3.1 Database Schema\n\n```sql\nCREATE TABLE files (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,               -- Filename without path\n    name_lower TEXT NOT NULL,         -- Lowercase for case-insensitive search\n    extension TEXT,                   -- File extension (lowercase)\n    path TEXT NOT NULL,               -- Full path\n    parent_path TEXT NOT NULL,        -- Parent directory path\n    size INTEGER,                     -- File size (NULL for cloud-only)\n    date_created INTEGER,             -- Creation timestamp\n    date_modified INTEGER,            -- Modification timestamp \n    file_type TEXT,                   -- UTType identifier\n    is_directory INTEGER NOT NULL,    -- 1 if directory, 0 if file\n    cloud_provider TEXT,              -- NULL, 'iCloud', 'Dropbox', etc.\n    cloud_status INTEGER,             -- 0=local, 1=downloaded, 2=cloud-only\n    indexed_at INTEGER NOT NULL       -- Timestamp of last indexing\n);\n\nCREATE TABLE directories (\n    id INTEGER PRIMARY KEY,\n    path TEXT NOT NULL UNIQUE,        -- Directory path\n    included INTEGER NOT NULL,        -- 1 if included, 0 if excluded\n    priority INTEGER NOT NULL,        -- Higher number takes precedence\n    recursive INTEGER NOT NULL,       -- 1 if rule applies to subdirectories\n    permission_state INTEGER NOT NULL -- Current permission status\n);\n\nCREATE TABLE file_types (\n    id INTEGER PRIMARY KEY,\n    extension TEXT NOT NULL UNIQUE,   -- Lowercase extension without dot\n    type_name TEXT NOT NULL,          -- User-friendly type name\n    category TEXT NOT NULL            -- Category for tab grouping\n);\n\nCREATE TABLE tabs (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,               -- Display name\n    filter_def TEXT NOT NULL,         -- JSON filter definition\n    position INTEGER NOT NULL,        -- Order in tab bar\n    visible INTEGER NOT NULL          -- 1 if visible, 0 if hidden\n);\n\nCREATE TABLE indexing_log (\n    id INTEGER PRIMARY KEY,\n    timestamp INTEGER NOT NULL,       -- Operation timestamp\n    operation TEXT NOT NULL,          -- 'initial', 'incremental', etc.\n    path TEXT,                        -- Related path if applicable\n    file_count INTEGER,               -- Number of files processed\n    duration INTEGER                  -- Operation duration in milliseconds\n);\n\nCREATE TABLE schema_version (\n    id INTEGER PRIMARY KEY CHECK (id = 1),  -- Single row table\n    version TEXT NOT NULL,                  -- Semantic version (Major.Minor.Patch)\n    updated_at INTEGER NOT NULL             -- Last update timestamp\n);\n\nCREATE TABLE permission_bookmarks (\n    id INTEGER PRIMARY KEY,\n    path TEXT NOT NULL UNIQUE,        -- Path this bookmark grants access to\n    bookmark BLOB NOT NULL,           -- Security-scoped bookmark data\n    created_at INTEGER NOT NULL       -- Creation timestamp\n);\n```\n\n### 3.2 Key Optimization Strategies\n\n1. **Indexing for Common Queries**:\n```sql\nCREATE INDEX idx_files_name ON files(name_lower);         -- Fast name search\nCREATE INDEX idx_files_ext ON files(extension);           -- Extension filtering\nCREATE INDEX idx_files_path ON files(path);               -- Path lookup\nCREATE INDEX idx_files_parent ON files(parent_path);      -- Parent directory queries\nCREATE INDEX idx_files_type ON files(file_type);          -- File type filtering\nCREATE INDEX idx_files_cloud ON files(cloud_provider, cloud_status); -- Cloud status\n```\n\n2. **In-Memory Caching**:\n   - Radix tree for fast path prefix matching\n   - LRU cache for frequent queries\n   - Metadata cache for active directories\n\n3. **Query Optimization**:\n   - Prepared statements for all common operations\n   - Transaction batching for bulk operations\n   - Write-ahead logging for crash resilience\n\n### 3.3 Data Lifecycle Management\n\n1. **Database Versioning**:\n   - Schema version tracked in dedicated table\n   - Simple forward migrations applied automatically\n   - Backup before schema changes\n\n2. **Integrity Protection**:\n   - Journaling with synchronous mode\n   - Periodic integrity checks with auto-repair\n   - Automatic backup on corruption detection\n\n3. **Cleanup Processes**:\n   - Periodic pruning of deleted file references\n   - Database vacuuming during idle periods\n   - Cache invalidation on index updates\n\n## 4. Critical OS Touchpoint Protection\n\n### 4.1 FSEvents Monitoring Resilience\n\n**Risk**: macOS has historically changed file system monitoring APIs and behavior\n\n**Protection Strategy**:\n1. **FSEvents Wrapper**:\n   - Isolate all FSEvents interactions within a dedicated component\n   - Implement a polling-based fallback mechanism when FSEvents fails\n   - Add shadow verification to detect missed events on network storage\n\n2. **Change Detection Interface**:\n   - Create a stable file change notification interface\n   - Support graceful degradation to less efficient mechanisms\n   - Implement adaptive event coalescing based on system load\n\n3. **Path Monitoring Strategies**:\n   - Support both recursive and path-specific monitoring\n   - Handle network path monitoring limitations\n   - Provide event validation and recovery mechanisms\n\n### 4.2 Permission and Security Model Adaptation\n\n**Risk**: macOS security model has become increasingly restrictive\n\n**Protection Strategy**:\n1. **Permission Management**:\n   - Implement security-scoped bookmark handling for persistent access\n   - Create progressive permission acquisition with minimum required access\n   - Add permission state visualization for user awareness\n\n2. **Access Levels**:\n   - Design for minimal permissions (standard user directories)\n   - Support enhanced capabilities with Security-Scoped Bookmarks\n   - Gracefully utilize Full Disk Access when available\n   - Properly handle cloud storage permission delegation\n\n3. **Operation Delegation**:\n   - Implement file operation strategies based on available permissions\n   - Provide clear user guidance for permission requirements\n   - Maintain functionality with limited permissions\n\n### 4.3 Cloud Storage Provider Integration\n\n**Risk**: Cloud providers frequently change APIs and integration methods\n\n**Protection Strategy**:\n1. **Provider Detection**:\n   - Use path patterns and attributes for provider identification\n   - Implement behavior-based detection over provider-specific code\n   - Support common providers (iCloud, Dropbox, Google Drive, OneDrive, Box)\n\n2. **Operation Handling**:\n   - Create provider-agnostic file operation interfaces\n   - **CRITICAL**: All cloud file operations (open, reveal, download) must be delegated to the system/Finder using NSWorkspace or equivalent\n   - Never implement direct cloud provider APIs or handle sync/download internally\n   - Support offline handling by delegating to Finder which manages sync status\n\n3. **Status Visualization**:\n   - Implement consistent cloud file indicators\n   - Support cloud-only placeholder visualization\n   - Provide download progress for cloud files\n\n### 4.4 UI Framework Integration\n\n**Risk**: AppKit evolves with each macOS version\n\n**Protection Strategy**:\n1. **Component Composition**:\n   - Use composition over inheritance for UI components\n   - Create clear separation between presentation and business logic\n   - Implement focused UI adapters for volatile components\n\n2. **Event Handling**:\n   - Use standard AppKit patterns for event processing\n   - Implement consistent keyboard and mouse handling\n   - Support accessibility through standard protocols\n\n3. **Layout Management**:\n   - Use Auto Layout for flexible positioning\n   - Support dynamic type and different display densities\n   - Maintain consistent visual appearance across OS versions\n\n## 5. Concurrency Architecture\n\n### 5.1 Thread Model with GIL Mitigation\n\n1. **Thread Domains**:\n   - UI Domain: Main thread only\n   - Indexing Domain: Background thread pool\n   - Search Domain: Dedicated optimized thread\n   - I/O Domain: Asynchronous operation queue\n   - Monitoring Domain: Event processing queue\n\n2. **GIL Contention Management**:\n   - Clear thread confinement with ownership boundaries\n   - Batch operations to minimize transitions\n   - Strategic use of PyObjC autorelease pools\n\n3. **Resource Adaptation**:\n   - Dynamic thread pool sizing based on system capabilities\n   - Thread priority management for responsive UI\n   - Throttling during resource constraints\n\n### 5.2 Task Prioritization\n\n1. **Priority Levels**:\n   - Critical: UI responsiveness, search operations\n   - High: File operations, visibility updates\n   - Normal: Incremental indexing, metadata extraction\n   - Background: Full indexing, database optimization\n   - Idle: Analytics, cleanup operations\n\n2. **Scheduling System**:\n   - Preemptive scheduling for high-priority tasks\n   - Work stealing for balanced distribution\n   - Energy-aware scheduling on battery power\n\n### 5.3 Memory Management\n\n1. **Ownership Model**:\n   - Explicit object ownership across thread boundaries\n   - Memory pressure monitoring and adaptation\n   - Caching with size limits\n\n2. **PyObjC Memory Management**:\n   - Explicit autorelease pool management\n   - Controlled crossing of language boundaries\n   - Careful management of Objective-C object references\n\n## 6. Interface Architecture\n\n### 6.1 Service Interface Contract\n\nAll internal services follow a standard interface pattern:\n\n```python\nclass ServiceInterface:\n    \"\"\"Base interface that all services must implement.\"\"\"\n    \n    def initialize(self):\n        \"\"\"Initialize the service.\"\"\"\n        raise NotImplementedError\n        \n    def shutdown(self):\n        \"\"\"Gracefully shut down the service.\"\"\"\n        raise NotImplementedError\n        \n    def get_status(self):\n        \"\"\"Return the current service status.\"\"\"\n        raise NotImplementedError\n```\n\nSpecific service interfaces extend this base with their specialized methods.\n\n### 6.2 Event Bus Design\n\nThe event bus provides a decoupled communication system:\n\n1. **Event Types**:\n   - `FileSystemEvent`: File creation, modification, deletion\n   - `IndexingEvent`: Indexing start, progress, completion\n   - `SearchEvent`: Query execution, results available\n   - `UIEvent`: User interaction tracking\n   - `SystemEvent`: Application lifecycle events\n\n2. **Subscription Model**:\n```python\ndef subscribe(event_type, callback):\n    \"\"\"Subscribe to an event type.\"\"\"\n    pass\n    \ndef unsubscribe(event_type, callback):\n    \"\"\"Unsubscribe from an event type.\"\"\"\n    pass\n    \ndef publish(event_type, event_data):\n    \"\"\"Publish an event to all subscribers.\"\"\"\n    pass\n```\n\n3. **Event Format**:\n```python\n{\n    \"type\": \"EventType\",\n    \"timestamp\": 1620000000,\n    \"data\": {\n        # Event-specific data\n    },\n    \"source\": \"ComponentName\"\n}\n```\n\n### 6.3 Error Handling Strategy\n\n1. **Error Categories**:\n   - User Input Errors: Invalid queries, unsupported operations\n   - System Errors: File access issues, database problems\n   - Resource Errors: Memory exhaustion, disk space\n   - External Errors: Cloud service failures, network issues\n\n2. **Recovery Strategies**:\n   - Automatic retry for transient failures\n   - Graceful degradation for unavailable services\n   - User notification for blocking issues\n   - Automatic repair for corrupted state\n\n3. **Error Format**:\n```python\n{\n    \"code\": \"ERROR_CODE\",\n    \"message\": \"Human-readable message\",\n    \"severity\": \"INFO|WARNING|ERROR|CRITICAL\",\n    \"component\": \"ComponentName\",\n    \"timestamp\": 1620000000,\n    \"recoverable\": True,\n    \"details\": {\n        # Error-specific details\n    }\n}\n```\n\n## 7. Extension Architecture\n\n### 7.1 Content Search Extension Point\n\nWhile Phase 1 focuses exclusively on filename search, the architecture includes extension points for future content search capabilities:\n\n1. **Database Schema Extension**:\n```sql\nCREATE TABLE content_index (\n    id INTEGER PRIMARY KEY,\n    file_id INTEGER NOT NULL,         -- Reference to files table\n    content_type TEXT NOT NULL,       -- 'text', 'pdf', 'doc', etc.\n    content TEXT NOT NULL,            -- Extracted text content\n    language TEXT,                    -- Detected language\n    indexed_at INTEGER NOT NULL,      -- Timestamp of indexing\n    FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE\n);\n\nCREATE VIRTUAL TABLE content_fts USING fts5(\n    content,\n    content='content_index',\n    content_rowid='id'\n);\n```\n\n2. **Extractor Interface**:\n```python\nclass ContentExtractorInterface(ServiceInterface):\n    \"\"\"Interface for content extraction implementations.\"\"\"\n    \n    def supports_file_type(self, file_type):\n        \"\"\"Check if this extractor supports the given file type.\"\"\"\n        raise NotImplementedError\n        \n    def extract_content(self, file_path, file_type):\n        \"\"\"Extract content from the file and return structured data.\"\"\"\n        raise NotImplementedError\n        \n    def get_supported_types(self):\n        \"\"\"Return list of supported file types.\"\"\"\n        raise NotImplementedError\n```\n\n### 7.2 OCR Extension Point\n\nOCR capabilities will be added in a future phase:\n\n1. **OCR Service Interface**:\n```python\nclass OCRServiceInterface(ServiceInterface):\n    \"\"\"Interface for OCR service implementations.\"\"\"\n    \n    def scan_image(self, image_path, languages=None, options=None):\n        \"\"\"Perform OCR on the given image and return extracted text.\"\"\"\n        raise NotImplementedError\n        \n    def scan_pdf(self, pdf_path, page_range=None, languages=None, options=None):\n        \"\"\"Perform OCR on the given PDF and return extracted text by page.\"\"\"\n        raise NotImplementedError\n        \n    def get_supported_formats(self):\n        \"\"\"Return list of supported image formats.\"\"\"\n        raise NotImplementedError\n```\n\n2. **OCR Database Schema**:\n```sql\nCREATE TABLE ocr_results (\n    id INTEGER PRIMARY KEY,\n    file_id INTEGER NOT NULL,             -- Reference to files table\n    page_number INTEGER,                  -- NULL for images, page for PDFs\n    text TEXT NOT NULL,                   -- Extracted text\n    confidence REAL,                      -- OCR confidence score (0-1)\n    language TEXT,                        -- Detected language\n    coordinates TEXT,                     -- JSON text region coordinates\n    processed_at INTEGER NOT NULL,        -- Timestamp of processing\n    FOREIGN KEY (file_id) REFERENCES files (id) ON DELETE CASCADE\n);\n\nCREATE VIRTUAL TABLE ocr_fts USING fts5(\n    text,\n    content='ocr_results',\n    content_rowid='id'\n);\n```\n\n## 8. Security Architecture\n\n### 8.1 Permission Model\n\n1. **Access Levels**:\n   - Standard Access: User directory access\n   - Extended Access: User-selected folders via security-scoped bookmarks\n   - Full Access: Complete visibility through Full Disk Access\n\n2. **Permission Persistence**:\n   - Security-scoped bookmarks for persistent access\n   - Permission state tracking in directory table\n   - Clear visualization of accessible areas\n\n3. **Degradation Strategy**:\n   - Function with minimal permissions\n   - Clearly communicate limitation boundaries\n   - Provide guidance for permission acquisition\n\n### 8.2 Data Security\n\n1. **Local-Only Storage**:\n   - No data transmission off-device\n   - Integration with FileVault for encryption\n   - Secure deletion of temporary files\n\n2. **Privacy Protection**:\n   - No telemetry or usage tracking\n   - No unique identifiers generated\n   - No cloud synchronization of index\n\n3. **Update Security**:\n   - Signed and notarized application\n   - Sparkle with ed25519 signatures\n   - Update verification before installation\n\n## 9. Observability Architecture\n\n### 9.1 Logging Framework\n\n1. **Log Levels**:\n   - DEBUG: Detailed developer information\n   - INFO: General operational information\n   - WARNING: Potential issues that don't block functionality\n   - ERROR: Operation failures that impact functionality\n   - CRITICAL: System-level failures requiring immediate attention\n\n2. **Log Structure**:\n```python\n{\n    \"timestamp\": \"ISO8601 timestamp\",\n    \"level\": \"LOG_LEVEL\",\n    \"component\": \"ComponentName\",\n    \"message\": \"Human-readable message\",\n    \"context\": {\n        # Operation-specific context\n    }\n}\n```\n\n3. **Log Storage**:\n   - Rolling file logs with size limits\n   - Console output in debug mode\n   - System log integration for critical errors\n\n### 9.2 Performance Metrics\n\n1. **Core Metrics**:\n   - Query Execution Time: Time from query start to results\n   - UI Render Time: Frame time for UI updates\n   - Indexing Rate: Files processed per second\n   - Memory Usage: By component and operation\n   - Thread Utilization: Activity across thread pools\n\n2. **Collection Approach**:\n   - Instrumentation of critical paths\n   - Sampling for high-volume operations\n   - Aggregation for trend analysis\n\n3. **Threshold Alerting**:\n   - Warning thresholds for core metrics\n   - Automatic diagnostics for threshold violations\n   - User notification for severe performance issues\n\n## 10. Quality & Testing Architecture\n\n### 10.1 Test Categories\n\n1. **Unit Tests**:\n   - Component isolation with mocks\n   - Comprehensive coverage (\u226595%)\n   - Performance validation\n\n2. **Integration Tests**:\n   - Component interaction validation\n   - Real file system testing\n   - Cloud provider simulation\n\n3. **Performance Tests**:\n   - Search latency benchmarks\n   - Indexing speed measurements\n   - Memory consumption tracking\n   - CPU utilization profiling\n\n4. **Accessibility Tests**:\n   - VoiceOver compatibility\n   - Keyboard navigation verification\n   - Color contrast compliance\n   - Dynamic type support\n\n### 10.2 Quality Gates\n\n1. **Code Quality**:\n   - Static analysis with mypy and flake8\n   - Cyclomatic complexity limits (max 10)\n   - Line length restrictions (max 500 lines per file)\n   - Documentation requirements\n\n2. **Performance Gates**:\n   - Search latency \u2264 50ms\n   - Launch time \u2264 100ms\n   - UI rendering \u2265 60fps\n   - Memory usage within budgets\n\n3. **Test Coverage**:\n   - Unit test coverage \u2265 95%\n   - Critical path coverage 100%\n   - Edge case validation\n\n## 11. Critical Design Decisions\n\n### 11.1 Technology Stack Selection\n\n1. **Primary Language**: Python 3.11+\n   - **Rationale**: Balance of development speed and performance\n   - **Alternatives Considered**: Swift (steeper learning curve), Rust (longer development time)\n   - **Risks**: Global Interpreter Lock, memory management\n   - **Mitigation**: Thread confinement, explicit memory management, critical path optimization\n   - **Build Strategy**: \n     * Prototype in PyObjC + Python 3.11+ with minimal dependencies\n     * Bundle with py2app using excludes for unused modules\n     * Final compilation with Nuitka for self-contained binary\n     * Optional UPX compression of .so/.dylib files\n\n2. **UI Framework**: Native AppKit via PyObjC\n   - **Rationale**: Native look and feel, optimal performance\n   - **Alternatives Considered**: Qt (non-native appearance), Tkinter (limited capabilities)\n   - **Risks**: PyObjC memory leaks, API complexity\n   - **Mitigation**: Explicit ownership patterns, composition over inheritance\n\n3. **Database**: SQLite\n   - **Rationale**: Embedded, zero configuration, proven performance\n   - **Alternatives Considered**: Core Data (tighter coupling), LMDB (less Python support)\n   - **Risks**: Concurrent access limitations, potential corruption\n   - **Mitigation**: Connection pooling, WAL mode, integrity checks\n\n### 11.2 Architectural Style Decisions\n\n1. **Component-Based Architecture**:\n   - **Rationale**: Clear responsibility boundaries, modularity\n   - **Alternatives Considered**: Layered architecture (less flexible), microkernel (too complex)\n   - **Risks**: Interface proliferation, potential overhead\n   - **Mitigation**: Strategic interface consolidation, component registries\n\n2. **Event-Driven Communication**:\n   - **Rationale**: Decoupling components, async operations\n   - **Alternatives Considered**: Direct method calls (tighter coupling), callbacks (callback hell)\n   - **Risks**: Event tracking complexity, potential missed events\n   - **Mitigation**: Event logging, delivery guarantees, error handling\n\n3. **Service Container Pattern**:\n   - **Rationale**: Dependency injection, testability\n   - **Alternatives Considered**: Singletons (testing difficulty), global state (maintenance issues)\n   - **Risks**: Configuration complexity, startup overhead\n   - **Mitigation**: Lazy initialization, service hierarchies\n\n### 11.3 Performance Strategy Decisions\n\n1. **Radix Tree for Path Matching**:\n   - **Rationale**: Optimal prefix matching performance\n   - **Alternatives Considered**: Trie (more memory), B-tree (slower for prefixes)\n   - **Risks**: Implementation complexity, memory usage\n   - **Mitigation**: Custom implementation with memory optimization\n\n2. **Thread Confinement for GIL Management**:\n   - **Rationale**: Predictable performance, avoid contention\n   - **Alternatives Considered**: Process pools (IPC overhead), async (less control)\n   - **Risks**: Thread coordination complexity, potential deadlocks\n   - **Mitigation**: Clear ownership rules, timeout mechanisms\n\n3. **Virtual UI Rendering**:\n   - **Rationale**: Efficient handling of large result sets\n   - **Alternatives Considered**: Full table rendering (poor performance), paging (worse UX)\n   - **Risks**: Implementation complexity, edge case handling\n   - **Mitigation**: Careful view recycling, background preparation\n\n## 12. Risk Assessment\n\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| Full Disk Access denial | High | High | Graceful degradation to Security-Scoped Bookmarks |\n| PyObjC memory management issues | High | Medium | Strict ownership patterns, autorelease pool management |\n| Database corruption | Medium | High | Transaction journaling, integrity checks, automated repair |\n| FSEvents reliability on network shares | High | Medium | Multiple monitoring strategies, shadow-tree verification |\n| Performance degradation at scale | Medium | High | Progressive loading, virtualization, sampling profiler |\n| Cloud provider changes | Medium | Medium | Feature detection, fallback mechanisms |\n| UI responsiveness during heavy indexing | High | Medium | Background threading, prioritization, throttling |\n| GIL contention | High | Medium | Thread confinement, operation batching |\n| Accessibility compliance | Medium | Medium | Regular testing, keyboard-first development |\n| Path rule complexity | Medium | Medium | Rule compiler, optimization, precomputed matches |\n\n## 13. Conclusion\n\nThis architecture provides a pragmatic foundation for the development of Panoptikon, focusing on protecting the most volatile OS touchpoints while avoiding unnecessary abstraction in stable components. By strategically applying bulletproofing techniques to file system monitoring, permission handling, cloud integration, and UI framework interaction, the system achieves an effective balance between immediate development efficiency and long-term maintainability.\n\nThe modular design ensures stability over a multi-year horizon while supporting rapid implementation of the Phase 1 MVP. The architecture balances the need for ultra-fast performance with the constraints of Python and PyObjC, implementing strategic optimizations for critical paths and resource management.",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase5_Prompt",
    "identifier": "spec/phases/phase5_prompt.md",
    "text": "# \ud83d\udea7 PHASE 5: SEARCH ENGINE\n\n## \ud83d\udcdd OBJECTIVES\n- Implement high-performance filename search engine\n- Create flexible query parser with pattern support\n- Build optimized search algorithm\n- Develop result management and organization\n- Implement sorting and filtering system\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Query Parser**:\n   - Implement filename pattern parsing\n   - Create wildcard and glob support\n   - Build query optimization\n   - Support advanced search operators\n\n2. **Search Algorithm**:\n   - Build optimized search implementation\n   - Create index-based search for performance\n   - Implement memory-efficient matching\n   - Design caching for frequent searches\n\n3. **Result Management**:\n   - Create result collection and organization\n   - Implement virtual result paging\n   - Build result caching and invalidation\n   - Support result annotation and grouping\n\n4. **Sorting System**:\n   - Implement flexible result sorting\n   - Create multi-key sort support\n   - Build sort direction control\n   - Support custom sort functions\n\n5. **Filtering System**:\n   - Build filter application framework\n   - Implement file type and attribute filters\n   - Create date range filtering\n   - Support custom filter chains\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify search completes in <50ms for 10k test files\n- Test query parser with various pattern types\n- Validate result accuracy across search terms\n- Measure search performance with benchmarks\n- Verify filtering correctly reduces result sets\n- Test sorting with various criteria\n- Maintain 95% code coverage\n\n## \ud83d\udeab CONSTRAINTS\n- Optimize for performance from the start\n- Design for thread safety in search operations\n- Support incremental result delivery\n- Maintain clear separation from UI components\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 3 path management\n- Phase 4 database access",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_5_Integrity",
    "identifier": "spec/phases/phase4_5_integrity.md",
    "text": "# \ud83d\udee1\ufe0f PHASE 4.5: DATA INTEGRITY PROTECTION\n\n## \ud83d\udcdd OBJECTIVES\n- Configure Write-Ahead Logging (WAL) mode\n- Implement integrity verification system\n- Create automated repair mechanisms\n- Design backup and recovery processes\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n### 1. WAL Configuration \ud83d\udcdd\n- **Enable WAL Mode**: Better concurrency and crash recovery\n- **Checkpoint Strategy**: Automatic and manual checkpoints\n- **WAL Size Management**: Prevent unbounded growth\n- **Synchronization Modes**: Balance safety vs performance\n\n### 2. Integrity Checking System \ud83d\udd0d\n```python\n# Integrity verification:\n# - PRAGMA integrity_check\n# - Foreign key constraint validation\n# - Index consistency verification\n# - Page-level corruption detection\n```\n\n### 3. Automated Repair \ud83d\udd27\n1. Detect corruption patterns\n2. Attempt automatic fixes\n3. Rebuild corrupted indexes\n4. Recreate damaged relationships\n5. Fallback to backup restoration\n\n### 4. Backup System \ud83d\udcbe\n- **Scheduled Backups**: Regular automatic backups\n- **Hot Backup**: Using SQLite backup API\n- **Compression**: Space-efficient storage\n- **Rotation Policy**: Manage backup retention\n- **Verification**: Test backup integrity\n\n### 5. Recovery Procedures \ud83d\ude91\n- **Point-in-time Recovery**: WAL-based restoration\n- **Selective Restoration**: Table-level recovery\n- **Corruption Isolation**: Quarantine bad data\n- **Recovery Testing**: Automated recovery drills\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Test WAL mode configuration\n- Verify checkpoint behavior\n- Simulate database corruption\n- Test automatic repair mechanisms\n- Validate backup creation and restoration\n- Test recovery procedures\n- Measure integrity check performance\n- Maintain 95% code coverage\n\n## \ud83c\udfaf SUCCESS CRITERIA\n- Zero data loss in crash scenarios\n- Integrity checks complete < 2 seconds\n- Successful recovery from corruption\n- Backup/restore < 10 seconds for 1GB\n- Automated repair success rate > 80%\n\n## \ud83d\udeab CONSTRAINTS\n- Use only SQLite built-in features\n- Backup size manageable (compressed)\n- Recovery time < 30 seconds\n- Minimal performance impact in WAL mode\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 4.1-4.4: All database components\n- Phase 2: File system operations (backups)\n- Phase 2: Scheduling system (automated backups)\n- Phase 2: Notification system (alerts)\n\n## \ud83c\udfd7\ufe0f CODE STANDARDS\n- **Error Handling**: Detailed corruption reporting\n- **Logging**: Comprehensive integrity logs\n- **Testing**: Corruption simulation framework\n- **Documentation**: Recovery procedures\n- **Metrics**: Integrity check timings\n- **Alerts**: Corruption detection notifications",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Read_Panoptikon Development Roadmap",
    "identifier": "spec/phases/read_panoptikon-development-roadmap.md",
    "text": "# Panoptikon Development Roadmap - Pragmatic Approach\n\n## 1. Overview\n\nThis roadmap outlines the development process for Panoptikon, a high-performance macOS filename search utility. It provides a structured approach for a single developer working with Cursor AI to implement the system architecture and deliver the Phase 1 MVP while strategically bulletproofing only the most critical OS-dependent components.\n\nThe roadmap is organized into phases with clear milestones, deliverables, and quality gates. Each phase builds upon the previous one, gradually constructing the complete system while maintaining testability, quality, and focused OS resilience throughout the process.\n\n## 2. Development Phases\n\n### 2.1 Phase 1: Foundation (Weeks 1-2)\n\n**Focus**: Establish the core project structure, development environment, and foundational components.\n\n#### 2.1.1 Development Environment Setup\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Environment Configuration | Set up Python 3.11+ with virtual environment | 0.5 day |\n| Build System | Create Makefile with development targets | 0.5 day |\n| IDE Setup | Configure IDE with linting and type checking | 0.5 day |\n| CI Pipeline | Set up basic CI for automated testing | 1 day |\n\n#### 2.1.2 Core Architecture Implementation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Project Structure | Create directory structure and package organization | 0.5 day |\n| Service Container | Implement dependency injection container | 1 day |\n| Event Bus | Create event publication/subscription system | 1 day |\n| Configuration System | Build settings management framework | 1 day |\n| Error Handling | Implement error reporting and recovery system | 1 day |\n\n#### 2.1.3 Critical OS Abstraction Implementation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| FSEvents Wrapper | Create isolation layer for file system monitoring | 1.5 days |\n| FS Access Abstraction | Implement permission-aware file system operations | 1.5 days |\n| Cloud Detection | Build provider-agnostic cloud storage detection | 1 day |\n| Permission Management | Create security-scoped bookmark handling | 1 day |\n\n#### 2.1.4 Database Foundation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Schema Creation | Implement core database schema | 1 day |\n| Connection Pool | Create thread-safe connection management | 1 day |\n| Migration System | Build simple schema migration framework | 1 day |\n| Query Optimization | Design and implement prepared statements | 1 day |\n\n#### 2.1.5 Milestone: Foundation Ready\n\n**Deliverables**:\n- Functional development environment with automated testing\n- Service container with dependency registration\n- Event bus with publish/subscribe capabilities\n- Key OS abstraction layers for critical components\n- SQLite database with schema versioning\n- Basic configuration system\n\n**Quality Gates**:\n- 95% test coverage for all components\n- All linters pass with zero warnings\n- Documentation for all public interfaces\n- Successful database migrations\n- FSEvents wrapper properly isolated\n\n### 2.2 Phase 2: Core Engine (Weeks 3-5)\n\n**Focus**: Implement the core search and indexing capabilities that form the heart of the application.\n\n#### 2.2.1 Search Engine Implementation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Query Parser | Implement filename pattern parsing | 2 days |\n| Search Algorithm | Build optimized search implementation | 3 days |\n| Result Management | Create result collection and organization | 1 day |\n| Sorting System | Implement flexible result sorting | 1 day |\n| Filtering System | Build filter application framework | 2 days |\n\n#### 2.2.2 File System Integration with Resilience\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| FSEvents Implementation | Create native FSEvents integration | 1 day |\n| Fallback Monitoring | Build polling-based alternative for reliability | 2 days |\n| Path Management | Implement path normalization and handling | 1 day |\n| Path Rule System | Build include/exclude rule evaluation | 2 days |\n| Metadata Extraction | Create file metadata extraction | 2 days |\n\n#### 2.2.3 Permission-Aware Operations\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Security-Scoped Bookmarks | Implement bookmark creation and restoration | 1 day |\n| Permission Detection | Build access rights verification | 1 day |\n| Permission Guidance | Create user guidance for required access | 1 day |\n| Operation Delegation | Implement permission-aware file operations | 2 days |\n\n#### 2.2.4 Indexing System\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Initial Scanner | Build recursive directory scanning | 2 days |\n| Incremental Updates | Implement change-based index updates | 2 days |\n| Batch Processing | Create efficient batch database operations | 1 day |\n| Progress Tracking | Implement indexing progress monitoring | 1 day |\n| Priority Management | Build intelligent scanning prioritization | 1 day |\n\n#### 2.2.5 Milestone: Functional Core\n\n**Deliverables**:\n- Working search engine with wildcard support\n- File system monitoring with resilience strategy\n- Complete indexing system with incremental updates\n- Path inclusion/exclusion rule evaluation\n- Permission-aware file operations\n- Basic file operations\n\n**Quality Gates**:\n- Search completes in <50ms for 10k test files\n- Indexing processes >1000 files/second\n- File monitoring correctly captures changes with multiple strategies\n- Path rules correctly filter files\n- Permission handling works with different access levels\n- 95% test coverage maintained\n\n### 2.3 Phase 3: UI Framework (Weeks 6-8)\n\n**Focus**: Create the native user interface and interaction model that provides the dual-paradigm experience.\n\n#### 2.3.1 Window and Controls\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Main Window | Implement primary application window | 2 days |\n| Search Field | Create search input with real-time filtering | 1 day |\n| Tab Bar | Build category filtering system | 2 days |\n| Results Table | Implement virtual table view for results | 3 days |\n| Column Management | Create customizable column system | 2 days |\n\n#### 2.3.2 Interaction Model\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Keyboard Shortcuts | Implement comprehensive keyboard navigation | 1 day |\n| Context Menus | Create right-click operation menus | 2 days |\n| Drag and Drop | Implement drag support for files | 2 days |\n| Selection Management | Build multiple item selection handling | 1 day |\n| Double-Click Actions | Implement default file actions | 0.5 day |\n\n#### 2.3.3 UI Component Abstraction\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Component Composition | Implement composition over inheritance for UI | 2 days | \n| Presentation-Logic Separation | Create clear boundary between UI and business logic | 1 day |\n| Accessibility Framework | Implement VoiceOver compatibility | 2 days |\n| Layout Adaptation | Build support for different screen densities | 1 day |\n\n#### 2.3.4 Progress and Feedback\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Progress Overlay | Create non-intrusive progress visualization | 1 day |\n| Status Bar | Implement informational status display | 1 day |\n| Tooltips | Add contextual information tooltips | 1 day |\n| Error Presentation | Build user-friendly error notifications | 1 day |\n| Animation System | Create smooth transitions and indicators | 1 day |\n\n#### 2.3.5 Milestone: Interactive UI\n\n**Deliverables**:\n- Complete user interface with search field, tabs, and results\n- Dual-paradigm interaction supporting keyboard and mouse\n- Context menus with file operations\n- Progress visualization for background operations\n- Drag and drop support\n- Resilient UI implementation for key components\n\n**Quality Gates**:\n- UI renders at 60fps during normal operations\n- All functions accessible via keyboard and mouse\n- Interface follows macOS Human Interface Guidelines\n- VoiceOver compatibility for accessibility\n- Tooltips provide clear guidance for both paradigms\n- Component abstraction properly isolates UI framework dependencies\n\n### 2.4 Phase 4: Integration (Weeks 9-10)\n\n**Focus**: Connect all components and implement cloud provider integration, preferences, and system integration.\n\n#### 2.4.1 Cloud Provider Integration\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Provider Detection | Implement cloud storage identification | 2 days |\n| Status Visualization | Create indicators for cloud files | 1 day |\n| Operation Delegation | Build provider-specific handling | 2 days |\n| Placeholder Support | Implement cloud-only file indicators | 1 day |\n| Offline Handling | Create graceful offline experience | 1 day |\n\n#### 2.4.2 Preferences System\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Preferences Panel | Build configuration interface | 2 days |\n| Path Rule Editor | Create include/exclude rule management | 2 days |\n| Tab Customization | Implement tab creation and editing | 1 day |\n| Column Settings | Build column visibility and order control | 1 day |\n| Settings Persistence | Implement preference saving/loading | 1 day |\n\n#### 2.4.3 System Integration with Resilience\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Global Hotkey | Implement system-wide activation with fallbacks | 1.5 days |\n| Menu Bar Icon | Create status item with menu | 1 day |\n| Dock Integration | Build proper dock icon behavior | 0.5 day |\n| Finder Integration | Implement reveal in Finder function | 1 day |\n| Permissions Management | Create Full Disk Access guidance | 1.5 days |\n\n#### 2.4.4 Milestone: Complete Integration\n\n**Deliverables**:\n- Full cloud provider support (iCloud, Dropbox, OneDrive, Google Drive, Box)\n- Comprehensive preferences management\n- System integration with hotkey, menu bar, and dock\n- Permissions handling with graceful degradation\n- Complete file operations across all storage types\n\n**Quality Gates**:\n- Cloud files correctly identified and handled\n- Preferences correctly persisted between launches\n- System integration functions as expected\n- Graceful behavior with limited permissions\n- Operations work consistently across storage types\n- Alternative system integration methods work when primary fails\n\n### 2.5 Phase 5: Optimization (Weeks 11-12)\n\n**Focus**: Fine-tune performance, memory usage, and user experience to meet or exceed all targets.\n\n#### 2.5.1 Performance Optimization\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Launch Time | Optimize application startup to <100ms | 2 days |\n| Search Latency | Fine-tune search to consistently <50ms | 2 days |\n| UI Responsiveness | Ensure 60fps rendering at all times | 2 days |\n| Indexing Speed | Optimize to handle 250k files in <60s | 2 days |\n| Resource Usage | Minimize memory and CPU footprint | 2 days |\n\n#### 2.5.2 Memory Management\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Memory Profiling | Identify and fix memory leaks | 2 days |\n| Cache Optimization | Fine-tune caching strategies | 1 day |\n| PyObjC Boundary | Optimize language crossing patterns | 2 days |\n| Thread Confinement | Ensure proper object ownership | 1 day |\n| Resource Scaling | Implement dynamic resource adjustment | 1 day |\n\n#### 2.5.3 Resilience Verification\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| File Monitoring Testing | Verify correct operation across scenarios | 1 day |\n| Permission Testing | Validate behavior with various permission levels | 1 day |\n| Cloud Integration Testing | Test across cloud providers and conditions | 1 day |\n| UI Framework Testing | Verify component abstraction effectiveness | 1 day |\n| Error Recovery | Test and enhance recovery mechanisms | 1 day |\n\n#### 2.5.4 User Experience Refinement\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| First-Run Experience | Create welcoming onboarding | 1 day |\n| Help System | Implement contextual guidance | 1 day |\n| Keyboard Shortcuts | Finalize and document shortcuts | 0.5 day |\n| Visual Refinement | Polish UI details and animations | 2 days |\n| Feedback Mechanisms | Add subtle user guidance | 0.5 day |\n\n#### 2.5.5 Milestone: Production Ready\n\n**Deliverables**:\n- Performance-optimized application meeting all targets\n- Memory-efficient implementation with no leaks\n- Verified resilience for critical OS touchpoints\n- Polished user experience with first-run guidance\n- Complete help documentation\n- Final visual refinements\n\n**Quality Gates**:\n- Launch time consistently <100ms\n- Search latency consistently <50ms\n- UI renders at 60fps under all conditions\n- Indexing handles 250k files in <60s\n- Idle memory usage <50MB\n- Bundle size <30MB\n- All tests passing with \u226595% coverage\n- File monitoring works reliably across different conditions\n- Graceful behavior with permission changes\n- Consistent operation with cloud provider variation\n\n### 2.6 Phase 6: Packaging and Release (Week 13)\n\n**Focus**: Create the final application bundle, complete documentation, and prepare for distribution.\n\n#### 2.6.1 Final Packaging\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Prototype Refinement | Finalize PyObjC + Python 3.11+ implementation with minimal dependencies | 1 day |\n| py2app Bundling | Bundle with py2app using excludes for unused modules | 1 day |\n| Nuitka Compilation | Compile to self-contained binary using Nuitka | 1.5 days |\n| Application Wrapping | Wrap with Platypus or build .app bundle manually | 0.5 day |\n| Size Optimization | UPX compress .so/.dylib files, clean unused locales/resources | 1 day |\n| Code Signing | Sign application with developer ID | 0.5 day |\n| Notarization | Submit for Apple notarization | 0.5 day |\n| DMG Creation | Package application for distribution | 0.5 day |\n\n#### 2.6.2 Documentation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| User Guide | Create comprehensive documentation | 2 days |\n| Release Notes | Prepare detailed release information | 0.5 day |\n| Known Issues | Document any limitations or issues | 0.5 day |\n| Future Roadmap | Outline planned enhancements | 0.5 day |\n| Developer Documentation | Finalize technical documentation | 1 day |\n\n#### 2.6.3 Release Preparation\n\n| Task | Description | Estimated Effort |\n|------|-------------|------------------|\n| Final Testing | Complete comprehensive test pass | 1 day |\n| Version Management | Set final version numbers | 0.5 day |\n| Update System | Configure Sparkle for updates | 1 day |\n| Website Preparation | Update website with release info | 1 day |\n| Distribution Channel | Prepare distribution mechanism | 0.5 day |\n\n#### 2.6.4 Milestone: Initial Release\n\n**Deliverables**:\n- Signed and notarized application bundle\n- Distribution-ready DMG package\n- Complete user and developer documentation\n- Configured update system\n- Website with release information\n\n**Quality Gates**:\n- Installation works via drag-and-drop\n- Application passes Gatekeeper validation\n- All features function as expected\n- Update system correctly detects new versions\n- Documentation covers all features and functions\n\n## 3. Testing Strategy\n\n### 3.1 Test Categories\n\n#### 3.1.1 Unit Tests\n\n- **Purpose**: Verify individual component functionality\n- **Implementation**: PyTest with component isolation\n- **Coverage Target**: \u226595% line coverage\n- **Automation**: Run on every commit\n- **Focus Areas**: Core algorithms, data structures, service implementations\n\n#### 3.1.2 Integration Tests\n\n- **Purpose**: Verify component interaction\n- **Implementation**: PyTest with minimal mocking\n- **Coverage**: Key integration points between major components\n- **Automation**: Run on pull requests and daily builds\n- **Focus Areas**: Search-index integration, UI-service communication, file system interaction\n\n#### 3.1.3 Resilience Tests\n\n- **Purpose**: Verify resilience of OS-dependent components\n- **Implementation**: Specialized test framework with failure simulation\n- **Coverage**: Critical OS touchpoints (file monitoring, permissions, cloud integration)\n- **Automation**: Run on pull requests and release candidates\n- **Focus Areas**: Fallback mechanisms, error recovery, permission adaptation\n\n#### 3.1.4 Performance Tests\n\n- **Purpose**: Ensure performance targets are met\n- **Implementation**: Benchmarking framework\n- **Coverage**: Critical user paths and operations\n- **Automation**: Run on pull requests and release candidates\n- **Focus Areas**: Search latency, indexing speed, UI responsiveness, memory usage\n\n#### 3.1.5 Accessibility Tests\n\n- **Purpose**: Verify accessibility compliance\n- **Implementation**: Manual testing with VoiceOver\n- **Coverage**: All UI elements and interactions\n- **Automation**: Partial automation with accessibility checker\n- **Focus Areas**: Keyboard navigation, screen reader compatibility, color contrast\n\n### 3.2 Continuous Integration Pipeline\n\n| Stage | Description | Trigger | Actions |\n|-------|-------------|---------|---------|\n| Build | Compile application | Every commit | Build application, run linters |\n| Unit Test | Run unit tests | Every commit | Execute all unit tests, measure coverage |\n| Integration Test | Run integration tests | Pull requests | Execute integration tests |\n| Resilience Test | Run resilience tests | Pull requests | Execute resilience tests for critical components |\n| Performance Test | Run performance benchmarks | Pull requests | Execute performance tests, compare to baseline |\n| Accessibility Check | Verify accessibility | Pull requests | Run automated accessibility checks |\n| Package | Create release bundle | Release branch | Build DMG, sign, and notarize |\n\n### 3.3 Release Qualification\n\nFinal release qualification includes:\n\n1. **Functional Verification**:\n   - Complete test pass of all features\n   - Verification across all supported macOS versions\n   - Testing with different storage configurations\n\n2. **Resilience Verification**:\n   - File monitoring reliability testing\n   - Permission change handling verification\n   - Cloud provider variation testing\n   - Network disconnect/reconnect scenarios\n   - System integration fallback verification\n\n3. **Performance Verification**:\n   - Search latency under varying index sizes\n   - Indexing performance with diverse file sets\n   - Memory usage during extended operation\n   - Launch time measurement\n\n4. **User Experience Validation**:\n   - First-run experience walkthrough\n   - Common workflow validation\n   - Keyboard and mouse interaction testing\n   - Accessibility verification with VoiceOver\n\n4. **Documentation Review**:\n   - User guide completeness\n   - Keyboard shortcut documentation\n   - Help system functionality\n   - Error message clarity\n\n## 4. Quality Assurance Metrics\n\n### 4.1 Code Quality Metrics\n\n| Metric | Target | Measurement Method |\n|--------|--------|-------------------|\n| Test Coverage | \u226595% | PyTest coverage reporting |\n| Cyclomatic Complexity | \u226410 | flake8-complexity plugin |\n| Module Size | \u2264500 lines | Line count verification |\n| Documentation | 100% public API | docstring coverage tool |\n| Type Annotations | 100% public API | mypy verification |\n| Linting | Zero warnings | flake8 with strict configuration |\n\n### 4.2 Performance Metrics\n\n| Metric | Target | Measurement Method |\n|--------|--------|-------------------|\n| Search Latency | <50ms | Automated timing of search execution |\n| Launch Time | <100ms | Startup time measurement |\n| UI Frame Rate | 60fps | Frame time measurement during operations |\n| Indexing Speed | >4000 files/second | Timed indexing of test corpus |\n| Memory Usage (idle) | <50MB | Process memory monitoring |\n| Memory Usage (active) | <200MB | Peak memory measurement during operation |\n| Bundle Size | <30MB | Final package size measurement |\n\n### 4.3 Resilience Metrics\n\n| Metric | Target | Measurement Method |\n|--------|--------|-------------------|\n| File Monitoring Reliability | >99% accuracy | Controlled file change testing |\n| Permission Degradation | 100% graceful fallback | Permission level simulation |\n| Cloud Provider Adaptability | 100% provider detection | Provider simulation testing |\n| Network Resilience | 100% recovery | Network interruption simulation |\n| System Integration | 100% operation with fallbacks | System service simulation |\n\n### 4.4 User Experience Metrics\n\n| Metric | Target | Measurement Method |\n|--------|--------|-------------------|\n| Task Completion | <1s for typical search | User testing with timing |\n| Error Rate | <1% of operations | Error logging and analysis |\n| Accessibility Score | 100% compliance | Accessibility audit |\n| First-Time Success | >90% of users | Onboarding completion tracking |\n| Keyboard Coverage | 100% of functions | Keyboard navigation verification |\n\n## 5. Risk Management Plan\n\n### 5.1 Technical Risks\n\n| Risk | Likelihood | Impact | Mitigation Plan | Owner | Status |\n|------|------------|--------|----------------|-------|--------|\n| FSEvents reliability | High | High | Multiple monitoring strategies, fallback to polling | Developer | Not Started |\n| PyObjC memory leaks | High | High | Strict ownership patterns, memory profiling | Developer | Not Started |\n| Database corruption | Medium | High | Transaction journaling, integrity checks | Developer | Not Started |\n| Performance degradation at scale | Medium | High | Progressive loading, virtualization | Developer | Not Started |\n| Cloud provider changes | Medium | Medium | Provider-agnostic detection, behavioral approach | Developer | Not Started |\n| GIL contention | High | Medium | Thread confinement, batch operations | Developer | Not Started |\n| UI responsiveness during indexing | High | Medium | Background threading, throttling | Developer | Not Started |\n\n### 5.2 Schedule Risks\n\n| Risk | Likelihood | Impact | Mitigation Plan | Owner | Status |\n|------|------------|--------|----------------|-------|--------|\n| UI implementation complexity | Medium | High | Early prototyping, incremental implementation | Developer | Not Started |\n| Performance optimization challenges | High | High | Regular benchmarking, early profiling | Developer | Not Started |\n| Cloud integration issues | Medium | Medium | Provider-specific testing early | Developer | Not Started |\n| File system monitoring complexity | High | Medium | Multiple strategy implementation early | Developer | Not Started |\n| Permission model challenges | Medium | Medium | Progressive implementation with verification | Developer | Not Started |\n| Apple review/notarization delays | Medium | Low | Early submission, compliance verification | Developer | Not Started |\n| Cursor AI integration limitations | Medium | Medium | Fallback plans for manual implementation | Developer | Not Started |\n\n### 5.3 Risk Monitoring\n\n- Weekly risk review and update\n- Risk-based testing focus\n- Early implementation of high-risk components\n- Regular performance testing throughout development\n- Resilience verification for critical OS touchpoints\n\n## 6. Development Tools and Environment\n\n### 6.1 Development Environment\n\n- **Operating System**: macOS Ventura (13.0) or later\n- **Development Hardware**: MacBook Pro with Apple Silicon (M1 or later)\n- **Target Hardware**: Apple Silicon and Intel Macs running macOS 13.0+\n- **Testing Environments**: Multiple macOS versions (13.0, 14.0)\n\n### 6.2 Development Tools\n\n| Tool | Purpose | Version |\n|------|---------|---------|\n| Python | Primary language | 3.11+ |\n| PyObjC | Native UI bridge | Latest compatible |\n| SQLite | Database | 3.39+ |\n| pytest | Testing framework | Latest |\n| mypy | Static type checking | Latest |\n| flake8 | Code linting | Latest |\n| py2app | Initial bundling | Latest |\n| Nuitka | Final compilation | Latest |\n| Platypus | App wrapping (alternative) | Latest |\n| UPX | Binary compression | Latest |\n| Cursor AI | Development assistant | Latest |\n\n### 6.3 Development Practices\n\n- **Version Control**: Git with feature branches\n- **Code Review**: Self-review with Cursor AI assistance\n- **Documentation**: Inline docstrings with separate guides\n- **Refactoring**: Regular cleanup and optimization\n- **Technical Debt**: Track and address regularly\n\n## 7. Resource Planning\n\n### 7.1 Development Resources\n\n- **Developer**: 1 full-time developer\n- **AI Assistance**: Cursor AI for code generation and review\n- **Testing**: Manual testing by developer, automated test suite\n- **Documentation**: Written by developer with AI assistance\n\n### 7.2 External Dependencies\n\n| Dependency | Purpose | Source | Alternative |\n|------------|---------|--------|------------|\n| PyObjC | Native UI | PyPI | Ctypes (limited) |\n| SQLite | Database | Built-in | LMDB (complex) |\n| FSEvents | File monitoring | macOS API | Polling (backup strategy) |\n| Sparkle | Updates | GitHub | Custom updater (complex) |\n\n### 7.3 Critical Path Management\n\n- Weekly review of milestone progress\n- Focus on high-risk components early (file monitoring, permissions, cloud integration)\n- Vertical slices for testable functionality\n- Regular integration of components\n- Testing of resilience mechanisms throughout development\n\n## 8. Post-Release Support Plan\n\n### 8.1 Monitoring and Feedback\n\n- **Crash Reporting**: Optional, privacy-respecting crash reports\n- **User Feedback**: Email support channel\n- **Performance Monitoring**: Local diagnostics on request\n- **Usage Patterns**: No telemetry, rely on user feedback\n\n### 8.2 Update Cadence\n\n- **Critical Fixes**: As needed, expedited release\n- **Minor Updates**: Monthly for the first 3 months\n- **Feature Updates**: Quarterly for Phase 1+\n- **Major Versions**: Annually for significant changes\n\n### 8.3 Support Commitments\n\n- **Bug Fixes**: 3 years for critical issues\n- **Compatibility**: Support for macOS 13.0+ until 2026\n- **Feature Requests**: Tracked and evaluated quarterly\n- **Documentation**: Maintained with each release\n\n## 9. Success Criteria\n\nThe Phase 1 development will be considered successful when:\n\n1. **Performance Targets**:\n   - Search latency consistently <50ms\n   - Launch time consistently <100ms\n   - UI rendering at 60fps under all conditions\n   - Indexing 250,000 files in <60 seconds\n\n2. **Quality Targets**:\n   - Zero known critical bugs\n   - Test coverage \u226595%\n   - All accessibility requirements met\n   - Bundle size <30MB\n\n3. **Resilience Targets**:\n   - File monitoring works reliably across scenarios\n   - Application functions with different permission levels\n   - Cloud integration adapts to provider variations\n   - System integration uses fallbacks when needed\n\n4. **User Experience**:\n   - Complete first-run experience\n   - Dual-paradigm support verified\n   - Cloud integration working seamlessly\n   - All core workflows tested and functional\n\n5. **System Integration**:\n   - Signed and notarized application\n   - Update system configured and tested\n   - Documentation complete and accurate\n   - Installation process verified\n\n6. **End-to-End Flow**:\n   - Users can find and open files within 1 second\n   - System works across all storage types\n   - Equal experience for Mac and Windows migrants\n   - Zero configuration required for cloud services\n\n## 10. Conclusion\n\nThis development roadmap provides a structured approach to delivering Panoptikon with a pragmatic focus on bulletproofing only the most critical OS-dependent components. By applying resilience techniques strategically to file system monitoring, permission handling, cloud integration, and system services, the plan balances development efficiency with long-term maintainability.\n\nThe emphasis on early implementation of high-risk components, multiple implementation strategies for volatile OS interfaces, and comprehensive testing will ensure a high-quality, performant, and resilient application that delivers on the promise: \"it knows where everything is with no blindspots.\"",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Read_Mcp_Knowledge_Graph",
    "identifier": "spec/phases/read_mcp_knowledge_graph.md",
    "text": "# \ud83d\udcca PANOPTIKON PROJECT - KNOWLEDGE GRAPH SUMMARY\n\n## \ud83c\udf10 Project Overview\n- **Name**: Panoptikon\n- **Description**: High-performance macOS filename search utility\n- **Goal**: Sub-50ms search across all storage with zero configuration\n- **Phases**: 11 implementation phases from initialization to release\n\n## \ud83c\udfd7\ufe0f Architecture Components\n\n### Core Infrastructure\n- Service Container (DI system)\n- Event Bus (communication)\n- Configuration System\n- Error Handling\n- Application Lifecycle\n\n### File System Layer\n- FSEvents Wrapper (with fallbacks)\n- FS Operations Abstraction\n- Cloud Provider Detection\n- Security-Scoped Bookmarks\n- Path Management\n\n### Data Layer\n- SQLite Database\n- Connection Pool\n- Migration System\n- Query Optimization\n- Data Integrity Protection\n\n### Search Engine\n- Query Parser\n- Search Algorithm\n- Result Management\n- Sorting System\n- Filtering System\n\n### Indexing System\n- Initial Scanner\n- Metadata Extraction\n- Incremental Updates\n- Priority Management\n- Progress Tracking\n\n### User Interface\n- Window and Controls\n- Interaction Model (keyboard + mouse)\n- UI Component Abstraction\n- Progress and Feedback\n- UI-Core Integration\n\n### System Integration\n- Global Hotkey\n- Menu Bar Icon\n- Dock Integration\n- Permissions Management\n- Finder Integration\n\n## \ud83d\udcc8 Performance Targets\n- Launch time: <100ms\n- Search latency: <50ms\n- UI responsiveness: 60fps\n- Indexing speed: 250k files in <60s\n- Memory footprint: <50MB idle\n- Bundle size: <30MB\n\n## \ud83d\udccf Quality Standards\n- Type checking: mypy with strict mode\n- Linting: flake8 with plugins\n- Test coverage: 95%+ across codebase\n- Complexity: Maximum 10 cyclomatic complexity\n- Documentation: Complete for all public interfaces\n\n## \ud83d\ude80 Technology Stack\n- Language: Python 3.11+\n- UI: AppKit via PyObjC\n- Database: SQLite with WAL mode\n- Packaging: py2app \u2192 Nuitka \u2192 signed .app bundle\n- Updates: Sparkle with ed25519 signatures\n\n## \ud83d\udd04 Phase Dependencies\n1. **Phase 1** \u2192 Project Setup (independent)\n2. **Phase 2** \u2192 Core Infrastructure (depends on 1)\n3. **Phase 3** \u2192 Filesystem Abstraction (depends on 2)\n4. **Phase 4** \u2192 Database Foundation (depends on 2)\n5. **Phase 5** \u2192 Search Engine (depends on 2, 3, 4)\n6. **Phase 6** \u2192 Indexing System (depends on 2, 3, 4)\n7. **Phase 7** \u2192 UI Framework (depends on 2, 5, 6)\n8. **Phase 8** \u2192 Cloud Integration (depends on 2, 3, 7)\n9. **Phase 9** \u2192 System Integration (depends on 2, 3, 7)\n10. **Phase 10** \u2192 Optimization (depends on all previous)\n11. **Phase 11** \u2192 Packaging (depends on all previous)\n\n## \u26a0\ufe0f Critical Risk Areas\n- FSEvents reliability (multiple monitoring strategies)\n- PyObjC memory leaks (strict ownership patterns)\n- Database corruption (transaction journaling)\n- Cloud provider changes (provider-agnostic detection)\n- Performance at scale (progressive loading)\n- Permission model changes (gradual permission acquisition)\n\n## \ud83e\uddea Testing Strategy\n- Unit tests for all components\n- Integration tests for component interactions\n- Performance benchmarks for critical paths\n- Resilience tests for OS-dependent components\n- Accessibility verification with VoiceOver",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase3_Prompt",
    "identifier": "spec/phases/phase3_prompt.md",
    "text": "# \ud83d\udea7 PHASE 3: FILESYSTEM ABSTRACTION\n\n## \ud83d\udcdd OBJECTIVES\n- Create resilient file system monitoring abstraction\n- Implement permission-aware file operations\n- Build cloud storage detection foundation\n- Develop security-scoped bookmark handling\n- Establish path normalization and handling system\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **FSEvents Wrapper**:\n   - Implement isolated FSEvents integration\n   - Create polling-based fallback mechanism\n   - Add event coalescing and filtering\n   - Design shadow verification for network storage\n\n2. **FS Access Abstraction**:\n   - Implement permission-aware file system operations\n   - Create file operation delegator with provider detection\n   - Support progressive permission acquisition\n   - Build permission state visualization system\n\n3. **Cloud Detection**:\n   - Implement cloud storage provider identification\n   - Create provider-agnostic detection mechanisms\n   - Support major providers (iCloud, Dropbox, OneDrive, Google Drive, Box)\n   - Design offline handling strategy\n\n4. **Security Bookmarks**:\n   - Implement security-scoped bookmark creation\n   - Create persistence and restoration mechanism\n   - Build bookmark management system\n   - Support sandbox-compatible file access\n\n5. **Path Management**:\n   - Implement path normalization and canonicalization\n   - Create path comparison utilities\n   - Build include/exclude rule evaluation system\n   - Develop efficient path storage and lookup\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Test FSEvents with various event scenarios\n- Verify fallback mechanism works when FSEvents fails\n- Validate cloud detection across providers\n- Confirm security bookmarks persist across restarts\n- Ensure path rules correctly filter files\n- Test operation with different permission levels\n- Maintain 95% code coverage\n\n## \ud83d\udeab CONSTRAINTS\n- Use dependency injection for all components\n- Design for testability with mock implementations\n- Focus on resilience against OS changes\n- Maintain clear abstraction boundaries\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 2 event bus\n- Phase 2 configuration system\n- Phase 2 error handling",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_2_To_4_3_Transition",
    "identifier": "spec/phases/phase4_2_to_4_3_transition.md",
    "text": "# Phase 4.2 to 4.3 Transition: Recommendations and Required Actions\n\n## Overview\n\nThis document outlines recommendations and required actions to complete before proceeding from Phase 4.2 (Connection Pool Management) to Phase 4.3 (Migration) in the Panoptikon project. The goal is to ensure technical debt is addressed, code quality and documentation meet project standards, and the codebase is ready for the next phase.\n\n## 1. Pydantic Validator Migration\n\n- **Current State:**\n  - The project uses Pydantic version 2 (as specified in `pyproject.toml`).\n  - Several configuration models (e.g., `DatabaseConfig` in `src/panoptikon/database/config.py`) still use Pydantic v1-style `@validator` decorators, which are deprecated in v2.\n- **Action Required:**\n  - Refactor all Pydantic validators to use the v2 `@field_validator` and `@model_validator` APIs.\n  - Remove any deprecated usage to ensure future compatibility and eliminate deprecation warnings.\n\n## 2. Code Quality and Documentation\n\n- **Thread-Safety Documentation:**\n  - Add or improve docstrings for all public classes and methods in the connection pool code, explicitly stating thread-safety guarantees and limitations.\n- **Custom Exception Hierarchy:**\n  - Ensure all pool-related errors use a custom exception hierarchy (e.g., `ConnectionPoolError`, `ConnectionAcquisitionTimeout`) and are documented.\n- **Context Manager Usage:**\n  - Document all context manager usage (for transactions, connections, etc.) in public API docstrings.\n- **SQLite Single-Writer Limitation:**\n  - Document how the pool handles SQLite's single-writer limitation and what users should expect under write contention.\n- **Type Hints and Linting:**\n  - Ensure all public functions/classes have type hints and docstrings.\n  - Run Black, isort, and Ruff (with --fix) to ensure code style compliance.\n\n## 3. Testing and Performance\n\n- **Test Coverage:**\n  - While new code is well-covered, the overall project coverage is only 31%. Increase coverage, especially for modules interacting with the pool, to move toward the 80\u201395% target.\n- **Performance Profiling:**\n  - Run and document performance tests for connection acquisition under high concurrency (100+ threads), as required by the phase spec.\n- **Stress/Leak Testing:**\n  - Run stress tests to ensure there are no connection leaks or deadlocks under heavy load.\n\n## 4. Documentation and Migration Readiness\n\n- **Developer Documentation:**\n  - Update developer docs and README to reflect the new pool system, configuration options, and usage patterns.\n- **API Reference:**\n  - Generate or update API reference docs for all new/changed public classes and functions.\n- **Migration Plan:**\n  - Prepare a migration plan for Phase 4.3, including any schema changes, data migration scripts, and rollback strategies.\n- **Backward Compatibility:**\n  - Ensure the new pool system is backward compatible with existing database files and configurations.\n\n## 5. Summary Table\n\n| Area                | Recommendation/Action                                             |\n|---------------------|-------------------------------------------------------------------|\n| Validators          | Migrate to Pydantic v2 APIs                                       |\n| Thread Safety       | Document guarantees/limitations                                   |\n| Exceptions          | Use and document custom exception hierarchy                       |\n| Context Managers    | Document usage in API docstrings                                  |\n| SQLite Limitation   | Document single-writer handling                                   |\n| Test Coverage       | Increase overall project coverage                                 |\n| Performance         | Profile connection acquisition under load                         |\n| Stress Testing      | Run leak/deadlock tests                                           |\n| Documentation       | Update developer/API docs                                         |\n| Code Standards      | Ensure type hints, docstrings, linting, formatting                |\n| Migration Plan      | Prepare for schema/data migration, ensure backward compatibility   |\n\n## 6. Next Steps\n\n- Review and discuss these recommendations with the team.\n- Assign action items and owners for each area.\n- Complete all required actions before starting Phase 4.3 (Migration).",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase2_Completion",
    "identifier": "spec/phases/phase2_completion.md",
    "text": "# \ud83c\udfc1 PHASE 2: CORE INFRASTRUCTURE - COMPLETION REPORT\n\n## \ud83d\udccb Overview\nPhase 2 focused on developing the core infrastructure components of the Panoptikon application, including service container, event bus, configuration system, error handling, and application lifecycle management. All objectives have been successfully completed.\n\n## \u2705 Completed Requirements\n\n### 1. Service Container\n- \u2713 Created `ServiceInterface` base class for injectable services\n- \u2713 Implemented container with registration and resolution:\n  - Support for singleton and transient service lifetimes\n  - Automatic constructor dependency injection\n  - Factory method support for complex construction scenarios\n- \u2713 Added lifecycle hooks (initialize, shutdown)\n- \u2713 Implemented dependency graph validation to prevent circular references\n- \u2713 Comprehensive unit tests for all functionality\n\n### 2. Event Bus\n- \u2713 Designed event types and payload structures:\n  - `EventBase` base class with required metadata\n  - Support for dataclass-based events\n  - JSON serialization for logging and persistence\n- \u2713 Implemented subscription/publication mechanism:\n  - Type-based event routing\n  - Priority-based event delivery\n  - Inherited event type handling\n- \u2713 Support for both synchronous and asynchronous event handling\n- \u2713 Added event logging and history for debugging\n\n### 3. Configuration System\n- \u2713 Created settings hierarchy:\n  - Default values defined in schema\n  - User settings from config files\n  - Runtime/temporary settings\n- \u2713 Implemented schema validation using Pydantic models\n- \u2713 Added hot reloading of configuration changes\n- \u2713 Support for secure handling of sensitive settings\n- \u2713 Event-based notification of configuration changes\n\n### 4. Error Handling\n- \u2713 Created structured error types and categories:\n  - Context-rich error objects\n  - Categorized errors (database, filesystem, etc.)\n  - Severity levels for appropriate handling\n- \u2713 Implemented error reporting through event system\n- \u2713 Added recovery mechanism for known error conditions\n- \u2713 Diagnostic information collection for troubleshooting\n- \u2713 Error history for post-mortem analysis\n\n### 5. Application Lifecycle\n- \u2713 Implemented startup/shutdown sequence:\n  - Orderly initialization and shutdown\n  - Signal handling (SIGTERM, SIGINT)\n  - Clean exit handling\n- \u2713 Created service initialization ordering through priorities\n- \u2713 Added resource cleanup on exit\n- \u2713 Implemented application state monitoring\n- \u2713 Event-based state change notifications\n\n## \ud83e\uddea Testing\n- Unit tests implemented for the service container\n- Manual verification of other components\n- Additional tests to be added in subsequent phases\n\n## \ud83d\udd17 Integration\nThe components are designed to work together seamlessly:\n- Services are registered in the container and automatically initialized\n- Components communicate through the event bus\n- Configuration changes trigger events\n- Errors are reported through the event system\n- Lifecycle manages the coordinated startup and shutdown\n\n## \ud83d\udcdd Notes\n- The components are designed to be platform-independent\n- No UI-specific code has been introduced yet, as specified in the constraints\n- The architecture supports both synchronous and asynchronous operations\n- Error handling is comprehensive and allows for graceful degradation\n\n## \ud83d\ude80 Next Steps\nWith the core infrastructure in place, the project is now ready to move to Phase 3, which will focus on implementing the search engine, file system integration, and indexing capabilities.\n\n## \ud83d\udce6 Code Structure\nThe implemented components are organized in the `core` module:\n```\nsrc/panoptikon/core/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 service.py     # Service container implementation\n\u251c\u2500\u2500 events.py      # Event bus implementation\n\u251c\u2500\u2500 config.py      # Configuration system\n\u251c\u2500\u2500 errors.py      # Error handling framework\n\u2514\u2500\u2500 lifecycle.py   # Application lifecycle management\n```\n\n## \ud83d\udd0d Additional Details\n- The service container performs dependency injection automatically by analyzing constructor parameter types\n- The event bus supports both class-based and function-based event handlers\n- The configuration system uses Pydantic for schema validation\n- The error handling system integrates with the event bus for notifications\n- The application lifecycle manages orderly startup and shutdown sequences",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_3_Migration",
    "identifier": "spec/phases/phase4_3_migration.md",
    "text": "# \ud83d\udd04 PHASE 4.3: SCHEMA MIGRATION FRAMEWORK\n\n## \ud83d\udcdd OBJECTIVES\n- Build automated schema versioning system\n- Implement forward migration execution\n- Create backup and recovery mechanisms\n- Support safe rollback capabilities\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n### 1. Migration System Core \ud83c\udfaf\n- **Version Tracking**: Schema version in database\n- **Migration Registry**: Ordered migration list\n- **Migration Executor**: Safe execution framework\n- **Backup Manager**: Pre-migration backups\n\n### 2. Migration Structure \ud83d\udcc1\n```python\n# Migration format:\n# - Version number (sequential)\n# - Up migration SQL\n# - Down migration SQL (optional)\n# - Verification queries\n# - Migration metadata\n```\n\n### 3. Safety Mechanisms \ud83d\udee1\ufe0f\n1. Pre-migration backup creation\n2. Transaction-wrapped migrations\n3. Post-migration verification\n4. Automatic rollback on failure\n5. Migration lock to prevent concurrent runs\n\n### 4. Recovery System \ud83d\ude91\n- **Backup Creation**: Full database backup before migration\n- **Integrity Checks**: Verify database consistency\n- **Recovery Process**: Restore from backup on failure\n- **History Tracking**: Log all migration attempts\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Test sequential migration execution\n- Verify rollback functionality\n- Test recovery from failed migrations\n- Validate backup creation and restoration\n- Test migration locking mechanism\n- Ensure idempotent migrations\n- Test with corrupted migration states\n- Maintain 95% code coverage\n\n## \ud83c\udfaf SUCCESS CRITERIA\n- Zero data loss during migrations\n- Migrations complete < 5 seconds for typical schemas\n- Automatic recovery from failures\n- Clear migration history tracking\n- Support for both up and down migrations\n\n## \ud83d\udeab CONSTRAINTS\n- Migrations must be atomic (all-or-nothing)\n- No external migration tools\n- Compatible with SQLite transaction limitations\n- Backup size must be manageable\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 4.1: Schema implementation (base schema)\n- Phase 4.2: Connection pool (database access)\n- Phase 2: Error handling (migration exceptions)\n- Phase 2: Configuration (backup location)\n\n## \ud83c\udfd7\ufe0f CODE STANDARDS\n- **Migration Naming**: Sequential numbering (001_initial.py)\n- **SQL Standards**: Consistent formatting, comments\n- **Error Messages**: Clear migration failure reasons\n- **Logging**: Detailed migration execution logs\n- **Testing**: Test each migration independently\n- **Documentation**: Migration purpose and impacts",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase9_Prompt",
    "identifier": "spec/phases/phase9_prompt.md",
    "text": "# \ud83d\udea7 PHASE 9: SYSTEM INTEGRATION\n\n## \ud83d\udcdd OBJECTIVES\n- Implement system-wide activation with global hotkey\n- Create menu bar integration with status item\n- Build dock icon behavior and integration\n- Develop permissions management and guidance\n- Implement Finder integration\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Global Hotkey**:\n   - Implement system-wide activation hotkey\n   - Create fallback mechanisms for different permission levels\n   - Build customizable shortcut configuration\n   - Design activation animation and feedback\n\n2. **Menu Bar Icon**:\n   - Create status item with menu\n   - Implement quick actions\n   - Build status visualization\n   - Support alternative activation path\n\n3. **Dock Integration**:\n   - Build proper dock icon behavior\n   - Implement badge notifications\n   - Create dock menu with actions\n   - Support drag and drop to dock icon\n\n4. **Permissions Management**:\n   - Create Full Disk Access guidance\n   - Implement permission detection\n   - Build progressive permission requests\n   - Design permission-aware operation routing\n\n5. **Finder Integration**:\n   - Implement reveal in Finder function\n   - Create file selection preservation\n   - Build contextual operations with Finder\n   - Support drag and drop between applications\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify hotkey works reliably\n   - Test with different permission levels\n   - Validate menu bar functions correctly\n   - Measure dock integration behavior\n   - Verify permissions guidance helps users\n   - Test Finder integration across operations\n   - Maintain graceful behavior with limited permissions\n\n## \ud83d\udeab CONSTRAINTS\n- Design for resilience against system service failures\n- Support fallback mechanisms for each integration\n- Maintain functionality with minimal permissions\n- Handle system service variations gracefully\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container\n- Phase 3 filesystem operations\n- Phase 3 permission bookmarks\n- Phase 7 UI framework",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase4_Prompt",
    "identifier": "spec/phases/phase4_prompt.md",
    "text": "# # \ud83d\udea7 PHASE 4: DATABASE FOUNDATION\n\n## \ud83d\udcdd OBJECTIVES\n- Implement SQLite database schema and versioning\n- Create thread-safe connection management\n- Build schema migration framework\n- Develop query optimization system\n- Establish data integrity protection\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Schema Creation**:\n   - Implement core database tables (files, directories, file_types, tabs)\n   - Create schema versioning table\n   - Add appropriate indexes for performance\n   - Design efficient schema for file metadata\n\n2. **Connection Pool**:\n   - Create thread-safe connection management\n   - Implement connection lifecycle hooks\n   - Add connection health monitoring\n   - Support transaction isolation levels\n\n3. **Migration System**:\n   - Build schema version detection\n   - Implement forward migration framework\n   - Create automated backup before migrations\n   - Support recovery from failed migrations\n\n4. **Query Optimization**:\n   - Design and implement prepared statements\n   - Create query parameterization helpers\n   - Build query execution plan monitoring\n   - Implement statement caching\n\n5. **Data Integrity**:\n   - Configure WAL journaling\n   - Implement integrity checks\n   - Create automated repair mechanisms\n   - Design backup and recovery system\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Verify schema migrations work correctly\n- Test connection pool under concurrent access\n- Validate data integrity after simulated crashes\n- Measure query performance with benchmarks\n- Ensure transactions maintain ACID properties\n- Verify backup and recovery mechanisms\n- Maintain 95% code coverage\n\n## \ud83d\udeab CONSTRAINTS\n- Use parameterized queries for all database access\n- Design for SQLite compatibility with no extensions\n- Ensure all operations are transaction-safe\n- Maintain backward compatibility in migrations\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 2 service container for injection\n- Phase 2 error handling for database exceptions\n- Phase 2 configuration for database settings",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Read_Style_Guide",
    "identifier": "spec/phases/read_style_guide.md",
    "text": "# Panoptikon Code Style Guide\n\nThis document outlines the coding standards and practices for the Panoptikon project. All code should adhere to these guidelines.\n\n## General Principles\n\n- **Quality First**: Prioritize code quality over development speed\n- **Readability**: Write code that is easy to understand\n- **Testability**: Design for testability from the beginning\n- **Maintainability**: Consider future maintenance in all design decisions\n\n## Python Coding Standards\n\n### Code Structure\n\n- **Line Length**: Maximum 120 characters\n- **File Size**: Maximum 500 lines per file\n- **Function Size**: Maximum 50 lines per function\n- **Class Size**: Maximum 200 lines per class\n- **Cyclomatic Complexity**: Maximum complexity of 10\n\n### Documentation\n\n- **Module Docstrings**: All modules must have a docstring\n- **Function Docstrings**: All public functions must have a docstring following Google style\n- **Class Docstrings**: All classes must have a docstring\n- **Method Docstrings**: All public methods must have a docstring\n- **Implementation Comments**: Complex algorithms need inline comments\n- **Docstring Coverage**: Minimum 95% docstring coverage\n\n### Type Annotations\n\n- **Function Parameters**: All parameters must have type annotations\n- **Return Values**: All functions must have return type annotations\n- **Variables**: Use type annotations for complex variables\n- **Generics**: Use typing.TypeVar for generic types\n- **Collections**: Use typing module for collections (List, Dict, etc.)\n- **Optional Values**: Use Optional[T] for nullable values\n- **Union Types**: Use Union[T1, T2] for multiple types\n\n### Imports\n\n- **Organization**: Group imports as standard library, third-party, local\n- **Formatting**: Use isort with black profile\n- **Aliasing**: Avoid import aliasing except for common patterns\n- **Wildcard Imports**: Never use wildcard imports (from module import *)\n- **Module vs. Object**: Prefer importing modules over objects\n\n### Naming Conventions\n\n- **Packages**: lowercase, no underscores\n- **Modules**: lowercase, underscores for readability\n- **Classes**: CapWords convention\n- **Functions**: lowercase, underscores for readability\n- **Variables**: lowercase, underscores for readability\n- **Constants**: UPPERCASE, underscores for readability\n- **Type Variables**: CapWords with short names\n\n### Code Style\n\n- **Formatting**: Use Black formatter with line length 120\n- **String Quotes**: Use double quotes for docstrings, single quotes for other strings\n- **String Formatting**: Use f-strings for string interpolation\n- **Comments**: Start with # and a space, sentence case, period at end\n- **Trailing Commas**: Use trailing commas in multi-line collections\n\n### Error Handling\n\n- **Specific Exceptions**: Catch specific exceptions, not bare except\n- **Error Messages**: Provide clear error messages\n- **Logging**: Use the logging module instead of print statements\n- **Context Managers**: Use context managers for resource management\n- **Error Propagation**: Raise exceptions at the appropriate level\n\n### Best Practices\n\n- **Path Handling**: Use pathlib instead of os.path\n- **File I/O**: Use context managers for file operations\n- **Dependencies**: Avoid circular dependencies\n- **Composition**: Prefer composition over inheritance\n- **Immutability**: Use immutable data structures when appropriate\n- **Constants**: Define constants at the module level\n- **Default Arguments**: Avoid mutable default arguments\n\n## Testing Standards\n\n- **Coverage**: Minimum 80% code coverage\n- **Unit Tests**: Write tests for all functionality\n- **Test Isolation**: Tests should not depend on each other\n- **Test Performance**: Tests should run quickly\n- **Test Naming**: Use descriptive test names\n- **Assertions**: Use appropriate assertions\n- **Fixtures**: Use fixtures for test setup\n- **Mocking**: Use mocking for external dependencies\n\n## Package Structure\n\n```\nsrc/panoptikon/\n\u251c\u2500\u2500 __init__.py            # Package initialization\n\u251c\u2500\u2500 index/                 # File indexing system\n\u251c\u2500\u2500 db/                    # Database operations\n\u251c\u2500\u2500 search/                # Search functionality\n\u251c\u2500\u2500 cloud/                 # Cloud provider integration\n\u251c\u2500\u2500 ui/                    # PyObjC interface\n\u251c\u2500\u2500 config/                # Application settings\n\u2514\u2500\u2500 utils/                 # Common utilities\n```\n\n## Commit Standards\n\n- **Atomic Commits**: Each commit should represent a single logical change\n- **Commit Messages**: Use descriptive commit messages\n- **Pre-Commit Hooks**: All commits must pass pre-commit hooks\n- **Branch Strategy**: Use feature branches for development\n\n## Quality Enforcement\n\n- **Linting**: All code must pass flake8, pylint, and ruff checks\n- **Type Checking**: All code must pass mypy type checking\n- **Formatting**: All code must be formatted with Black\n- **Pre-Commit**: Use pre-commit hooks to enforce standards\n- **CI/CD**: Automated quality checks in CI/CD pipeline",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase2_Prompt",
    "identifier": "spec/phases/phase2_prompt.md",
    "text": "# \ud83d\udea7 PHASE 2: CORE INFRASTRUCTURE\n\n## \ud83d\udcdd OBJECTIVES\n- Implement service container for dependency injection\n- Create event bus for component communication\n- Develop configuration system for settings management\n- Establish error handling framework\n- Build application lifecycle management\n\n## \ud83d\udd27 IMPLEMENTATION TASKS\n\n1. **Service Container**:\n   - Create ServiceInterface base class\n   - Implement container with registration, resolution, and lifecycle hooks\n   - Support singleton and transient service lifetimes\n   - Add dependency graph validation to prevent circular references\n\n2. **Event Bus**:\n   - Design event types and payload structures\n   - Implement subscription/publication mechanism\n   - Support synchronous and asynchronous event handling\n   - Add event logging and replay capabilities for debugging\n\n3. **Configuration System**:\n   - Create settings hierarchy (defaults, user, runtime)\n   - Implement schema validation for configuration\n   - Support hot reloading of configuration changes\n   - Add secure storage for sensitive settings\n\n4. **Error Handling**:\n   - Create structured error types and categories\n   - Implement error reporting and recovery system\n   - Design graceful degradation paths\n   - Build diagnostic information collection\n\n5. **Application Lifecycle**:\n   - Implement startup/shutdown sequence\n   - Create service initialization ordering\n   - Add resource cleanup on exit\n   - Support application state persistence\n\n## \ud83e\uddea TESTING REQUIREMENTS\n- Unit tests for all components with 95% coverage\n- Service resolution must handle complex dependencies\n- Event delivery must be verified across components\n- Configuration validation must catch invalid settings\n- Error handling must recover from expected failures\n- All components must initialize and shutdown cleanly\n\n## \ud83d\udeab CONSTRAINTS\n- No UI or OS-specific code yet\n- Maintain platform-independence where possible\n- Avoid premature optimization\n\n## \ud83d\udccb DEPENDENCIES\n- Phase 1 project structure and environment",
    "status": "active",
    "supersededBy": null,
    "inCategory": null,
    "dateModified": null,
    "dateCreated": null,
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "ADR-20250514-Block Phase 4.3 Until Testing",
    "identifier": "decisions/adr-20250514-block-phase-4.3-until-testing.md",
    "text": "# Block Phase 4.3 Until Testing\n\n## Status\nAccepted\n\n## Context\nPhase 4.2 has zero test coverage\n\n## Decision\nMust complete testing before migrations\n\n## Consequences\n1-2 week delay but stable foundation\n\n## Alternatives Considered\nNo alternatives documented.\n\n## Date\n2025-05-14",
    "status": "Accepted",
    "supersededBy": null,
    "inCategory": "decisions",
    "dateModified": "2025-05-14T00:30:13.961080",
    "dateCreated": "2025-05-14T00:30:13.961072",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Service Container",
    "identifier": "components/service-container.md",
    "text": "# Service Container\n\n## Overview\nDependency injection container with lifecycle management\n\n## Purpose\nManage service lifecycles and dependencies\n\n## Implementation\nImplementation details not available.\n\n## API\nAPI documentation pending.\n\n## Testing\nTesting information not available.\n\n## Dependencies\nNo dependencies listed.\n\n## Status\n- Implementation: Completed\n- Test Coverage: 94%\n- Last Updated: 2025-05-14",
    "status": "active",
    "supersededBy": null,
    "inCategory": "components",
    "dateModified": "2025-05-14T00:30:12.693939",
    "dateCreated": "2025-05-14T00:30:12.693933",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "DatabaseConnectionPool",
    "identifier": "components/databaseconnectionpool.md",
    "text": "# DatabaseConnectionPool\n\n## Overview\nThread-safe connection pooling for SQLite\n\n## Purpose\nManage database connections efficiently\n\n## Implementation\nImplementation details not available.\n\n## API\nAPI documentation pending.\n\n## Testing\nTesting information not available.\n\n## Dependencies\nNo dependencies listed.\n\n## Status\n- Implementation: Implemented\n- Test Coverage: 76%\n- Last Updated: 2025-05-14",
    "status": "active",
    "supersededBy": null,
    "inCategory": "components",
    "dateModified": "2025-05-14T03:07:03.513102",
    "dateCreated": "2025-05-14T03:07:03.513100",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase 2 - Core Infrastructure",
    "identifier": "phases/phase-2---core-infrastructure.md",
    "text": "# Phase 2 - Core Infrastructure\n\n## Objectives\nService container, event bus, configuration, error handling\n\n## Components\n['Service Container', 'Event Bus', 'Configuration System']\n\n## Status\nCompleted\n\n## Progress\nNo progress information.\n\n## Issues\nNo known issues.\n\n## Next Steps\nNext steps not defined.",
    "status": "Completed",
    "supersededBy": null,
    "inCategory": "phases",
    "dateModified": "2025-05-14T00:30:05.946484",
    "dateCreated": "2025-05-14T00:30:05.946251",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase 1 - Foundation",
    "identifier": "phases/phase-1---foundation.md",
    "text": "# Phase 1 - Foundation\n\n## Objectives\nEnvironment setup, core architecture, OS abstraction, database\n\n## Components\n['Project Structure', 'Build System', 'Testing Framework']\n\n## Status\nCompleted\n\n## Progress\nNo progress information.\n\n## Issues\nNo known issues.\n\n## Next Steps\nNext steps not defined.",
    "status": "Completed",
    "supersededBy": null,
    "inCategory": "phases",
    "dateModified": "2025-05-14T00:30:04.053107",
    "dateCreated": "2025-05-14T00:30:04.053091",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase 3 - Filesystem Abstraction",
    "identifier": "phases/phase-3---filesystem-abstraction.md",
    "text": "# Phase 3 - Filesystem Abstraction\n\n## Objectives\nFile system monitoring, security bookmarks, cloud detection\n\n## Components\n['FSEvents Wrapper', 'Security Bookmarks', 'Cloud Detection']\n\n## Status\nCompleted\n\n## Progress\nNo progress information.\n\n## Issues\nNo known issues.\n\n## Next Steps\nNext steps not defined.",
    "status": "Completed",
    "supersededBy": null,
    "inCategory": "phases",
    "dateModified": "2025-05-14T00:30:07.400319",
    "dateCreated": "2025-05-14T00:30:07.400313",
    "crossReferences": []
  },
  {
    "@context": "https://schema.org/",
    "@type": "CreativeWork",
    "name": "Phase 4 - Database Implementation",
    "identifier": "phases/phase-4---database-implementation.md",
    "text": "# Phase 4 - Database Implementation\n\n## Objectives\nSQLite integration with connection pooling\n\n## Components\n['Database Schema', 'Connection Pool', 'Migration System']\n\n## Status\nIn Progress\n\n## Progress\nNo progress information.\n\n## Issues\n['Phase 4.2 needs testing', 'Zero test coverage on connection pool']\n\n## Next Steps\nNext steps not defined.",
    "status": "In Progress",
    "supersededBy": null,
    "inCategory": "phases",
    "dateModified": "2025-05-14T00:30:08.915747",
    "dateCreated": "2025-05-14T00:30:08.915724",
    "crossReferences": []
  }
]